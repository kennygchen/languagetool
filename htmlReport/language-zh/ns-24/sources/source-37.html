


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > GRPCRule</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.languagetool.rules</a>
</div>

<h1>Coverage Summary for Class: GRPCRule (org.languagetool.rules)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">GRPCRule</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/18)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/66)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/145)
  </span>
</td>
</tr>
  <tr>
    <td class="name">GRPCRule$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">GRPCRule$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">GRPCRule$AnalyzedMLRuleRequest</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">GRPCRule$Connection</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/25)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">GRPCRule$GRPCSubRule</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">GRPCRule$MLRuleRequest</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/33)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/82)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/194)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; *  LanguageTool, a natural language style checker
&nbsp; *  * Copyright (C) 2018 Fabian Richter
&nbsp; *  *
&nbsp; *  * This library is free software; you can redistribute it and/or
&nbsp; *  * modify it under the terms of the GNU Lesser General Public
&nbsp; *  * License as published by the Free Software Foundation; either
&nbsp; *  * version 2.1 of the License, or (at your option) any later version.
&nbsp; *  *
&nbsp; *  * This library is distributed in the hope that it will be useful,
&nbsp; *  * but WITHOUT ANY WARRANTY; without even the implied warranty of
&nbsp; *  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
&nbsp; *  * Lesser General Public License for more details.
&nbsp; *  *
&nbsp; *  * You should have received a copy of the GNU Lesser General Public
&nbsp; *  * License along with this library; if not, write to the Free Software
&nbsp; *  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
&nbsp; *  * USA
&nbsp; *
&nbsp; */
&nbsp;
&nbsp;package org.languagetool.rules;
&nbsp;
&nbsp;import java.io.File;
&nbsp;import java.io.IOException;
&nbsp;import java.net.MalformedURLException;
&nbsp;import java.net.URL;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Collections;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Objects;
&nbsp;import java.util.ResourceBundle;
&nbsp;import java.util.concurrent.Callable;
&nbsp;import java.util.concurrent.ExecutionException;
&nbsp;import java.util.concurrent.TimeUnit;
&nbsp;import java.util.concurrent.TimeoutException;
&nbsp;import java.util.function.BiFunction;
&nbsp;import java.util.function.Function;
&nbsp;import java.util.regex.Pattern;
&nbsp;import java.util.stream.Collectors;
&nbsp;import java.util.stream.Stream;
&nbsp;
&nbsp;import javax.net.ssl.SSLException;
&nbsp;
&nbsp;import com.google.common.cache.CacheBuilder;
&nbsp;import com.google.common.cache.CacheLoader;
&nbsp;import com.google.common.cache.LoadingCache;
&nbsp;import com.google.common.collect.Streams;
&nbsp;import com.google.common.util.concurrent.ListenableFuture;
&nbsp;
&nbsp;import io.grpc.*;
&nbsp;import io.grpc.internal.DnsNameResolverProvider;
&nbsp;import org.jetbrains.annotations.Nullable;
&nbsp;import org.languagetool.AnalyzedSentence;
&nbsp;import org.languagetool.JLanguageTool;
&nbsp;import org.languagetool.Language;
&nbsp;import org.languagetool.Tag;
&nbsp;import org.languagetool.rules.ml.MLServerGrpc;
&nbsp;import org.languagetool.rules.ml.MLServerGrpc.MLServerFutureStub;
&nbsp;import org.languagetool.rules.ml.MLServerProto;
&nbsp;import org.languagetool.rules.ml.MLServerProto.MatchResponse;
&nbsp;import org.languagetool.tools.StringTools;
&nbsp;import org.slf4j.Logger;
&nbsp;import org.slf4j.LoggerFactory;
&nbsp;
&nbsp;import io.grpc.netty.shaded.io.grpc.netty.GrpcSslContexts;
&nbsp;import io.grpc.netty.shaded.io.grpc.netty.NegotiationType;
&nbsp;import io.grpc.netty.shaded.io.grpc.netty.NettyChannelBuilder;
&nbsp;import io.grpc.netty.shaded.io.netty.handler.ssl.SslContextBuilder;
&nbsp;
&nbsp;/**
&nbsp; * Base class fur rules running on external servers;
&nbsp; * see gRPC service definition in languagetool-core/src/main/proto/ml_server.proto
&nbsp; *
&nbsp; * See #create(Language, ResourceBundle, RemoteRuleConfig, boolean, String, String, Map)  for an easy way to add rules; return rule in Language::getRelevantRemoteRules
&nbsp; * add it like this:
&nbsp;  &lt;pre&gt;
&nbsp;   public List&amp;lt;Rule&amp;gt; getRelevantRemoteRules(ResourceBundle messageBundle, List&amp;lt;RemoteRuleConfig&amp;gt; configs, GlobalConfig globalConfig, UserConfig userConfig, Language motherTongue, List&amp;lt;Language&amp;gt; altLanguages) throws IOException {
&nbsp;     List&amp;lt;Rule&amp;gt; rules = new ArrayList&amp;lt;&amp;gt;(super.getRelevantRemoteRules(
&nbsp;     messageBundle, configs, globalConfig, userConfig, motherTongue, altLanguages));
&nbsp;     Rule exampleRule = GRPCRule.create(messageBundle,
&nbsp;       RemoteRuleConfig.getRelevantConfig(&quot;EXAMPLE_ID&quot;, configs),
&nbsp;      &quot;EXAMPLE_ID&quot;, &quot;example_rule_id&quot;,
&nbsp;      Collections.singletonMap(&quot;example_match_id&quot;, &quot;example_rule_message&quot;));
&nbsp;     rules.add(exampleRule);
&nbsp;     return rules;
&nbsp;   }
&nbsp;  &lt;/pre&gt;
&nbsp; */
&nbsp;public abstract class GRPCRule extends RemoteRule {
&nbsp;  public static final String CONFIG_TYPE = &quot;grpc&quot;;
&nbsp;
&nbsp;
<b class="nc">&nbsp;  private static final Logger logger = LoggerFactory.getLogger(GRPCRule.class);</b>
&nbsp;  private static final int DEFAULT_BATCH_SIZE = 8;
<b class="nc">&nbsp;  public static final Pattern WHITESPACE_REGEX = Pattern.compile(&quot;[\u00a0\u202f\ufeff\ufffd]&quot;);</b>
&nbsp;  private static final String DEFAULT_DESCRIPTION = &quot;INTERNAL - dynamically loaded rule supported by remote server&quot;;
&nbsp;  /*TODO Delete this temporal fix as this is for speeding up execution for too long sentences*/
&nbsp;
&nbsp;  public static String cleanID(String id, Language lang) {
<b class="nc">&nbsp;    return StringTools.toId(id, lang);</b>
&nbsp;  }
&nbsp;  /**
&nbsp;   * Internal rule to create rule matches with IDs based on Match Sub-IDs
&nbsp;   */
&nbsp;  public static class GRPCSubRule extends Rule {
&nbsp;    private final String matchId;
&nbsp;    private final String description;
&nbsp;
<b class="nc">&nbsp;    GRPCSubRule(MLServerProto.Match match, String description, Language lang) {</b>
<b class="nc">&nbsp;      String ruleId = match.getId();</b>
<b class="nc">&nbsp;      String subId = match.getSubId();</b>
<b class="nc">&nbsp;      if (subId != null &amp;&amp; !subId.trim().isEmpty()) {</b>
<b class="nc">&nbsp;        this.matchId = cleanID(ruleId, lang) + &quot;_&quot; + cleanID(subId, lang);</b>
&nbsp;      } else {
<b class="nc">&nbsp;        this.matchId = cleanID(ruleId, lang);</b>
&nbsp;      }
<b class="nc">&nbsp;      this.description = description;</b>
<b class="nc">&nbsp;      setTags(match.getRule().getTagsList().stream().map(t -&gt; Tag.valueOf(t.name())).collect(Collectors.toList()));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String getId() {
<b class="nc">&nbsp;      return matchId;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String getDescription() {
<b class="nc">&nbsp;      return this.description;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public RuleMatch[] match(AnalyzedSentence sentence) throws IOException {
<b class="nc">&nbsp;      throw new UnsupportedOperationException();</b>
&nbsp;    }
&nbsp;
&nbsp;  }
&nbsp;
&nbsp;  public static class Connection {
&nbsp;    final ManagedChannel channel;
&nbsp;    final MLServerFutureStub stub;
&nbsp;
&nbsp;    public static ManagedChannel getManagedChannel(String host, int port, boolean useSSL, @Nullable String clientPrivateKey, @Nullable String clientCertificate, @Nullable String rootCertificate) throws SSLException {
&nbsp;      NettyChannelBuilder channelBuilder;
<b class="nc">&nbsp;      if (host.startsWith(&quot;dns://&quot;)) {</b>
<b class="nc">&nbsp;        channelBuilder = NettyChannelBuilder.forTarget(host + &quot;:&quot; + port);</b>
<b class="nc">&nbsp;        channelBuilder.defaultLoadBalancingPolicy(&quot;round_robin&quot;);</b>
<b class="nc">&nbsp;        NameResolverRegistry.getDefaultRegistry().register(new DnsNameResolverProvider());</b>
&nbsp;      } else {
<b class="nc">&nbsp;        channelBuilder = NettyChannelBuilder.forAddress(host, port);</b>
&nbsp;      }
<b class="nc">&nbsp;      if (useSSL) {</b>
<b class="nc">&nbsp;        SslContextBuilder sslContextBuilder = GrpcSslContexts.forClient();</b>
<b class="nc">&nbsp;        if (rootCertificate != null) {</b>
<b class="nc">&nbsp;          sslContextBuilder.trustManager(new File(rootCertificate));</b>
&nbsp;        }
<b class="nc">&nbsp;        if (clientCertificate != null &amp;&amp; clientPrivateKey != null) {</b>
<b class="nc">&nbsp;          sslContextBuilder.keyManager(new File(clientCertificate), new File(clientPrivateKey));</b>
&nbsp;        }
<b class="nc">&nbsp;        channelBuilder = channelBuilder.negotiationType(NegotiationType.TLS).sslContext(sslContextBuilder.build());</b>
&nbsp;      } else {
<b class="nc">&nbsp;        channelBuilder = channelBuilder.usePlaintext();</b>
&nbsp;      }
<b class="nc">&nbsp;      return channelBuilder.build();</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    Connection(RemoteRuleConfig serviceConfiguration) throws SSLException {</b>
<b class="nc">&nbsp;      String host = serviceConfiguration.getUrl();</b>
<b class="nc">&nbsp;      int port = serviceConfiguration.getPort();</b>
<b class="nc">&nbsp;      boolean ssl = Boolean.parseBoolean(serviceConfiguration.getOptions().getOrDefault(&quot;secure&quot;, &quot;false&quot;));</b>
<b class="nc">&nbsp;      String key = serviceConfiguration.getOptions().get(&quot;clientKey&quot;);</b>
<b class="nc">&nbsp;      String cert = serviceConfiguration.getOptions().get(&quot;clientCertificate&quot;);</b>
<b class="nc">&nbsp;      String ca = serviceConfiguration.getOptions().get(&quot;rootCertificate&quot;);</b>
<b class="nc">&nbsp;      this.channel = getManagedChannel(host, port, ssl, key, cert, ca);</b>
<b class="nc">&nbsp;      this.stub = MLServerGrpc.newFutureStub(channel);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void shutdown() {
<b class="nc">&nbsp;      if (channel != null) {</b>
<b class="nc">&nbsp;        channel.shutdownNow();</b>
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private static final LoadingCache&lt;RemoteRuleConfig, Connection&gt; servers =
<b class="nc">&nbsp;    CacheBuilder.newBuilder().build(CacheLoader.from(serviceConfiguration -&gt; {</b>
<b class="nc">&nbsp;      if (serviceConfiguration == null) {</b>
<b class="nc">&nbsp;        throw new IllegalArgumentException(&quot;No configuration for connection given&quot;);</b>
&nbsp;      }
&nbsp;      try {
<b class="nc">&nbsp;        return new Connection(serviceConfiguration);</b>
&nbsp;      } catch (SSLException e) {
<b class="nc">&nbsp;        throw new RuntimeException(e);</b>
&nbsp;      }
&nbsp;    }));
&nbsp;
&nbsp;  static {
<b class="nc">&nbsp;    shutdownRoutines.add(() -&gt; servers.asMap().values().forEach(Connection::shutdown));</b>
&nbsp;  }
&nbsp;
&nbsp;  private final Connection conn;
&nbsp;  private final int batchSize;
&nbsp;  private final boolean sendAnalyzedData;
&nbsp;  private int maxSentenceLength;
&nbsp;
&nbsp;  public GRPCRule(Language language, ResourceBundle messages, RemoteRuleConfig config, boolean inputLogging) {
<b class="nc">&nbsp;    super(language, messages, config, inputLogging);</b>
&nbsp;
<b class="nc">&nbsp;    this.maxSentenceLength = Integer.parseInt(config.getOptions().getOrDefault(&quot;maxSentenceLength&quot;, String.valueOf(Integer.MAX_VALUE)));</b>
<b class="nc">&nbsp;    sendAnalyzedData = config.getOptions()</b>
<b class="nc">&nbsp;      .getOrDefault(&quot;analyzed&quot;, &quot;false&quot;)</b>
<b class="nc">&nbsp;      .equalsIgnoreCase(&quot;true&quot;);</b>
<b class="nc">&nbsp;    this.batchSize = Integer.parseInt(config.getOptions().getOrDefault(&quot;batchSize&quot;,</b>
<b class="nc">&nbsp;                                                                       String.valueOf(DEFAULT_BATCH_SIZE)));</b>
<b class="nc">&nbsp;    synchronized (servers) {</b>
<b class="nc">&nbsp;      Connection conn = null;</b>
&nbsp;        try {
<b class="nc">&nbsp;          conn = servers.get(serviceConfiguration);</b>
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;          logger.error(&quot;Could not connect to remote service at &quot; + serviceConfiguration, e);</b>
&nbsp;        }
<b class="nc">&nbsp;      this.conn = conn;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;  }
&nbsp;
&nbsp;  protected class MLRuleRequest extends RemoteRule.RemoteRequest {
&nbsp;    final List&lt;MLServerProto.MatchRequest&gt; requests;
&nbsp;    final List&lt;AnalyzedSentence&gt; sentences;
&nbsp;    final Long textSessionId;
&nbsp;
<b class="nc">&nbsp;    public MLRuleRequest(List&lt;MLServerProto.MatchRequest&gt; requests, List&lt;AnalyzedSentence&gt; sentences, Long textSessionId) {</b>
<b class="nc">&nbsp;      this.requests = requests;</b>
<b class="nc">&nbsp;      this.sentences = sentences;</b>
<b class="nc">&nbsp;      this.textSessionId = textSessionId;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;
&nbsp;  protected class AnalyzedMLRuleRequest extends RemoteRule.RemoteRequest {
&nbsp;    final List&lt;MLServerProto.AnalyzedMatchRequest&gt; requests;
&nbsp;    final List&lt;AnalyzedSentence&gt; sentences;
&nbsp;
<b class="nc">&nbsp;    public AnalyzedMLRuleRequest(List&lt;MLServerProto.AnalyzedMatchRequest&gt; requests, List&lt;AnalyzedSentence&gt; sentences) {</b>
<b class="nc">&nbsp;      this.requests = requests;</b>
<b class="nc">&nbsp;      this.sentences = sentences;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  protected RemoteRule.RemoteRequest prepareRequest(List&lt;AnalyzedSentence&gt; sentences, @Nullable Long textSessionId) {
<b class="nc">&nbsp;    List&lt;Long&gt; ids = Collections.emptyList();</b>
&nbsp;    // TODO this is a temp fix to avoid sending too long sentences to the server
<b class="nc">&nbsp;    List&lt;AnalyzedSentence&gt; filteredSentences = sentences.stream()</b>
<b class="nc">&nbsp;      .filter(s -&gt; s.getText().length() &lt;= maxSentenceLength)</b>
<b class="nc">&nbsp;      .collect(Collectors.toList());</b>
&nbsp;
<b class="nc">&nbsp;    if (textSessionId != null) {</b>
<b class="nc">&nbsp;      ids = Collections.nCopies(filteredSentences.size(), textSessionId);</b>
&nbsp;    }
<b class="nc">&nbsp;    if (sendAnalyzedData) {</b>
<b class="nc">&nbsp;      List&lt;MLServerProto.AnalyzedMatchRequest&gt; requests = new ArrayList&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;      for (int offset = 0; offset &lt; filteredSentences.size(); offset += batchSize) {</b>
<b class="nc">&nbsp;        MLServerProto.AnalyzedMatchRequest req = MLServerProto.AnalyzedMatchRequest.newBuilder()</b>
<b class="nc">&nbsp;          .addAllSentences(filteredSentences</b>
<b class="nc">&nbsp;            .subList(offset, Math.min(filteredSentences.size(), offset + batchSize))</b>
<b class="nc">&nbsp;            .stream().map(GRPCUtils::toGRPC).collect(Collectors.toList()))</b>
<b class="nc">&nbsp;          .setInputLogging(inputLogging)</b>
<b class="nc">&nbsp;          .addAllTextSessionID(textSessionId != null ?</b>
<b class="nc">&nbsp;            ids.subList(offset, Math.min(filteredSentences.size(), offset + batchSize))</b>
<b class="nc">&nbsp;            : Collections.emptyList())</b>
<b class="nc">&nbsp;          .build();</b>
<b class="nc">&nbsp;        requests.add(req);</b>
&nbsp;      }
<b class="nc">&nbsp;      return new AnalyzedMLRuleRequest(requests, filteredSentences);</b>
&nbsp;    } else {
<b class="nc">&nbsp;      List&lt;MLServerProto.MatchRequest&gt; requests = new ArrayList&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;      for (int offset = 0; offset &lt; filteredSentences.size(); offset += batchSize) {</b>
<b class="nc">&nbsp;        List&lt;String&gt; text = filteredSentences.stream().map(AnalyzedSentence::getText).map(s -&gt; {</b>
<b class="nc">&nbsp;          if (whitespaceNormalisation) {</b>
&nbsp;            // non-breaking space can be treated as normal space
<b class="nc">&nbsp;            return WHITESPACE_REGEX.matcher(s).replaceAll(&quot; &quot;);</b>
&nbsp;          } else {
<b class="nc">&nbsp;            return s;</b>
&nbsp;          }
<b class="nc">&nbsp;        }).collect(Collectors.toList());</b>
<b class="nc">&nbsp;        MLServerProto.MatchRequest req = MLServerProto.MatchRequest.newBuilder()</b>
<b class="nc">&nbsp;          .addAllSentences(text.subList(offset, Math.min(text.size(), offset + batchSize)))</b>
<b class="nc">&nbsp;          .setInputLogging(inputLogging)</b>
<b class="nc">&nbsp;          .addAllTextSessionID(textSessionId != null ?</b>
<b class="nc">&nbsp;                              ids.subList(offset, Math.min(text.size(), offset + batchSize))</b>
<b class="nc">&nbsp;                              : Collections.emptyList())</b>
<b class="nc">&nbsp;          .build();</b>
<b class="nc">&nbsp;        requests.add(req);</b>
&nbsp;      }
<b class="nc">&nbsp;      if (requests.size() &gt; 1) {</b>
<b class="nc">&nbsp;        logger.debug(&quot;Split {} sentences into {} requests for {}&quot;, filteredSentences.size(), requests.size(), getId());</b>
&nbsp;      }
<b class="nc">&nbsp;      return new MLRuleRequest(requests, filteredSentences, textSessionId);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  @Nullable
&nbsp;  private static String nonEmpty(String s) {
<b class="nc">&nbsp;    if (s.isEmpty()) {</b>
<b class="nc">&nbsp;      return null;</b>
&nbsp;    }
<b class="nc">&nbsp;    return s;</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  protected Callable&lt;RemoteRuleResult&gt; executeRequest(RemoteRequest requestArg, long timeoutMilliseconds) throws TimeoutException {
<b class="nc">&nbsp;    return () -&gt; {</b>
<b class="nc">&nbsp;      MLRuleRequest reqArgs = (MLRuleRequest) requestArg;</b>
&nbsp;      // NOTE: disabled for now, don&#39;t want to run this in the nightly diff
<b class="nc">&nbsp;      boolean noRegression = Boolean.parseBoolean(serviceConfiguration.getOptions().getOrDefault(&quot;no-regression&quot;, &quot;false&quot;));</b>
<b class="nc">&nbsp;      if (noRegression &amp;&amp; reqArgs.textSessionId != null &amp;&amp; (reqArgs.textSessionId == -1 || reqArgs.textSessionId == -2)) {</b>
<b class="nc">&nbsp;        return new RemoteRuleResult(false, true, Collections.emptyList(), reqArgs.sentences);</b>
&nbsp;      }
&nbsp;
&nbsp;      List&lt;AnalyzedSentence&gt; sentences;
<b class="nc">&nbsp;      List&lt;ListenableFuture&lt;MatchResponse&gt;&gt; futures = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;      List&lt;MatchResponse&gt; responses = new ArrayList&lt;&gt;();</b>
&nbsp;      try {
<b class="nc">&nbsp;        if (sendAnalyzedData) {</b>
<b class="nc">&nbsp;          AnalyzedMLRuleRequest reqData = (AnalyzedMLRuleRequest) requestArg;</b>
<b class="nc">&nbsp;          sentences = reqData.sentences;</b>
&nbsp;
<b class="nc">&nbsp;          for (MLServerProto.AnalyzedMatchRequest req : reqData.requests) {</b>
<b class="nc">&nbsp;            if (timeoutMilliseconds &gt; 0) {</b>
<b class="nc">&nbsp;              logger.debug(&quot;Deadline for rule {}: {}ms&quot;, getId(), timeoutMilliseconds);</b>
<b class="nc">&nbsp;              futures.add(conn.stub</b>
<b class="nc">&nbsp;                .withDeadlineAfter(timeoutMilliseconds, TimeUnit.MILLISECONDS)</b>
<b class="nc">&nbsp;                .matchAnalyzed(req));</b>
&nbsp;            } else {
<b class="nc">&nbsp;              futures.add(conn.stub.matchAnalyzed(req));</b>
&nbsp;            }
&nbsp;          }
&nbsp;        } else {
<b class="nc">&nbsp;          MLRuleRequest reqData = (MLRuleRequest) requestArg;</b>
<b class="nc">&nbsp;          sentences = reqData.sentences;</b>
&nbsp;
<b class="nc">&nbsp;          for (MLServerProto.MatchRequest req : reqData.requests) {</b>
<b class="nc">&nbsp;            if (timeoutMilliseconds &gt; 0) {</b>
<b class="nc">&nbsp;              logger.debug(&quot;Deadline for rule {}: {}ms&quot;, getId(), timeoutMilliseconds);</b>
<b class="nc">&nbsp;              futures.add(conn.stub</b>
<b class="nc">&nbsp;                .withDeadlineAfter(timeoutMilliseconds, TimeUnit.MILLISECONDS)</b>
<b class="nc">&nbsp;                .match(req));</b>
&nbsp;            } else {
<b class="nc">&nbsp;              futures.add(conn.stub.match(req));</b>
&nbsp;            }
&nbsp;          }
&nbsp;        }
&nbsp;        // TODO: handle partial failures
<b class="nc">&nbsp;        for (ListenableFuture&lt;MatchResponse&gt; res : futures) {</b>
<b class="nc">&nbsp;          responses.add(res.get());</b>
&nbsp;        }
&nbsp;      } catch (StatusRuntimeException e) {
<b class="nc">&nbsp;        if (e.getStatus().getCode() == Status.DEADLINE_EXCEEDED.getCode()) {</b>
<b class="nc">&nbsp;          throw new TimeoutException(e.getMessage());</b>
&nbsp;        } else {
&nbsp;          throw e;
&nbsp;        }
&nbsp;      } catch (InterruptedException | ExecutionException e) {
<b class="nc">&nbsp;        throw new TimeoutException(e + Objects.toString(e.getMessage()));</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      List&lt;RuleMatch&gt; matches = getRuleMatches(sentences, responses);</b>
<b class="nc">&nbsp;      RemoteRuleResult result = new RemoteRuleResult(true, true, matches, sentences);</b>
<b class="nc">&nbsp;      return result;</b>
&nbsp;    };
&nbsp;  }
&nbsp;
&nbsp;  private List&lt;RuleMatch&gt; getRuleMatches(List&lt;AnalyzedSentence&gt; sentences, List&lt;MatchResponse&gt; responses) {
<b class="nc">&nbsp;    BiFunction&lt;MLServerProto.MatchList, AnalyzedSentence, Stream&lt;RuleMatch&gt;&gt; createMatch = (matchList, sentence) -&gt; matchList.getMatchesList().stream().map(match -&gt; {</b>
<b class="nc">&nbsp;        String description = match.getRuleDescription();</b>
<b class="nc">&nbsp;        if (description == null || description.isEmpty()) {</b>
<b class="nc">&nbsp;          description = this.getDescription();</b>
<b class="nc">&nbsp;          if (description == null || description.isEmpty()) {</b>
<b class="nc">&nbsp;            throw new RuntimeException(&quot;Missing description for rule with ID &quot; + match.getId() + &quot;_&quot; + match.getSubId());</b>
&nbsp;          }
&nbsp;        }
<b class="nc">&nbsp;        GRPCSubRule subRule = new GRPCSubRule(match, description, ruleLanguage);</b>
<b class="nc">&nbsp;        String message = match.getMatchDescription();</b>
<b class="nc">&nbsp;        String shortMessage = match.getMatchShortDescription();</b>
<b class="nc">&nbsp;        if (message == null || message.isEmpty()) {</b>
<b class="nc">&nbsp;          message = getMessage(match, sentence);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (message == null || message.isEmpty()) {</b>
<b class="nc">&nbsp;          throw new RuntimeException(&quot;Missing message for match with ID &quot; + subRule.getId());</b>
&nbsp;        }
<b class="nc">&nbsp;        int start = match.getOffset();</b>
<b class="nc">&nbsp;        int end = start + match.getLength();</b>
<b class="nc">&nbsp;        RuleMatch m = new RuleMatch(subRule, sentence,</b>
&nbsp;          start, end,
&nbsp;          message, shortMessage);
<b class="nc">&nbsp;        if (!match.getUrl().isEmpty()) {</b>
&nbsp;          try {
<b class="nc">&nbsp;            m.setUrl(new URL(match.getUrl()));</b>
&nbsp;          } catch (MalformedURLException e) {
<b class="nc">&nbsp;            logger.warn(&quot;Got invalid URL from GRPC rule {}: {}&quot;, this, e);</b>
&nbsp;          }
&nbsp;        }
<b class="nc">&nbsp;        m.setAutoCorrect(match.getAutoCorrect());</b>
&nbsp;        // suggestedReplacements should override suggestions
<b class="nc">&nbsp;        if (match.getSuggestedReplacementsList().isEmpty()) {</b>
<b class="nc">&nbsp;          m.setSuggestedReplacements(match.getSuggestionsList());</b>
&nbsp;        } else {
<b class="nc">&nbsp;          m.setSuggestedReplacementObjects(match.getSuggestedReplacementsList().stream().map(s -&gt; {</b>
<b class="nc">&nbsp;            SuggestedReplacement repl = new SuggestedReplacement(</b>
<b class="nc">&nbsp;              s.getReplacement(), nonEmpty(s.getDescription()), nonEmpty(s.getSuffix()));</b>
<b class="nc">&nbsp;            if (s.getConfidence() &gt; 0.0) {</b>
<b class="nc">&nbsp;              repl.setConfidence(s.getConfidence());</b>
&nbsp;            }
<b class="nc">&nbsp;            return repl;</b>
<b class="nc">&nbsp;          }).collect(Collectors.toList()));</b>
&nbsp;        }
<b class="nc">&nbsp;        return m;</b>
&nbsp;      }
&nbsp;    );
&nbsp;
<b class="nc">&nbsp;    List&lt;RuleMatch&gt; matches = Streams.zip(</b>
<b class="nc">&nbsp;      responses.stream()</b>
<b class="nc">&nbsp;        .flatMap(res -&gt; res.getSentenceMatchesList().stream()),</b>
<b class="nc">&nbsp;      sentences.stream(),</b>
&nbsp;      createMatch)
<b class="nc">&nbsp;      .flatMap(Function.identity()).collect(Collectors.toList());</b>
<b class="nc">&nbsp;    return matches;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * messages can be provided by the ML server or the Java client
&nbsp;   * fill them in here or leave this empty if the server takes care of it
&nbsp;   */
&nbsp;  protected abstract String getMessage(MLServerProto.Match match, AnalyzedSentence sentence);
&nbsp;
&nbsp;  @Override
&nbsp;  protected RemoteRuleResult fallbackResults(RemoteRule.RemoteRequest request) {
<b class="nc">&nbsp;    MLRuleRequest req = (MLRuleRequest) request;</b>
<b class="nc">&nbsp;    return new RemoteRuleResult(false, false, Collections.emptyList(), req.sentences);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Helper method to create instances of RemoteMLRule
&nbsp;   * @param language rule language
&nbsp;   * @param messages for i18n; = JLanguageTool.getMessageBundle(lang)
&nbsp;   * @param config configuration for remote rule server;
&nbsp;   *               options: secure, clientKey, clientCertificate, rootCertificate
&nbsp;                   use RemoteRuleConfig.getRelevantConfig(id, configs)
&nbsp;                   to load this in Language::getRelevantRemoteRules
&nbsp;   * @param id ID of rule
&nbsp;   * @param descriptionKey key in MessageBundle.properties for rule description
&nbsp;   * @param messagesByID mapping match.sub_id -&amp;gt; key in MessageBundle.properties for RuleMatch&#39;s message
&nbsp;   * @return instance of RemoteMLRule
&nbsp;   */
&nbsp;  public static GRPCRule create(Language language, ResourceBundle messages, RemoteRuleConfig config, boolean inputLogging,
&nbsp;                                String id, String descriptionKey, Map&lt;String, String&gt; messagesByID) {
<b class="nc">&nbsp;    return new GRPCRule(language, messages, config, inputLogging) {</b>
&nbsp;
&nbsp;
&nbsp;      @Override
&nbsp;      protected String getMessage(MLServerProto.Match match, AnalyzedSentence sentence) {
<b class="nc">&nbsp;        return messages.getString(messagesByID.get(match.getSubId()));</b>
&nbsp;      }
&nbsp;
&nbsp;      @Override
&nbsp;      public String getDescription() {
<b class="nc">&nbsp;        return messages.getString(descriptionKey);</b>
&nbsp;      }
&nbsp;    };
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Helper method to create instances of RemoteMLRule
&nbsp;   * @param language rule language
&nbsp;   * @param config configuration for remote rule server;
&nbsp;   *               options: secure, clientKey, clientCertificate, rootCertificate
&nbsp;                   use RemoteRuleConfig.getRelevantConfig(id, configs)
&nbsp;                   to load this in Language::getRelevantRemoteRules
&nbsp;   * @param id ID of rule
&nbsp;   * @param description rule description
&nbsp;   * @param messagesByID mapping match.sub_id to RuleMatch&#39;s message
&nbsp;   * @return instance of RemoteMLRule
&nbsp;   */
&nbsp;  public static GRPCRule create(Language language, RemoteRuleConfig config, boolean inputLogging,
&nbsp;                                String id, String description, Map&lt;String, String&gt; messagesByID) {
<b class="nc">&nbsp;    return new GRPCRule(language, JLanguageTool.getMessageBundle(), config, inputLogging) {</b>
&nbsp;      @Override
&nbsp;      protected String getMessage(MLServerProto.Match match, AnalyzedSentence sentence) {
<b class="nc">&nbsp;        return messagesByID.get(match.getSubId());</b>
&nbsp;      }
&nbsp;      @Override
&nbsp;      public String getDescription() {
<b class="nc">&nbsp;        return description;</b>
&nbsp;      }
&nbsp;    };
&nbsp;  }
&nbsp;
&nbsp;  public static List&lt;GRPCRule&gt; createAll(Language language, List&lt;RemoteRuleConfig&gt; configs, boolean inputLogging, String prefix, String defaultDescription) {
<b class="nc">&nbsp;    return configs.stream()</b>
<b class="nc">&nbsp;      .filter(cfg -&gt; cfg.getRuleId().startsWith(prefix))</b>
<b class="nc">&nbsp;      .map(cfg -&gt; create(language, cfg, inputLogging, cfg.getRuleId(), defaultDescription, Collections.emptyMap()))</b>
<b class="nc">&nbsp;      .collect(Collectors.toList());</b>
&nbsp;  }
&nbsp;
&nbsp;  public static List&lt;GRPCRule&gt; createAll(Language language, List&lt;RemoteRuleConfig&gt; configs, boolean inputLogging) {
<b class="nc">&nbsp;    return configs.stream()</b>
<b class="nc">&nbsp;      .filter(RemoteRuleConfig.isRelevantConfig(CONFIG_TYPE, language))</b>
<b class="nc">&nbsp;      .map(cfg -&gt; create(language, cfg, inputLogging, cfg.getRuleId(), DEFAULT_DESCRIPTION, Collections.emptyMap()))</b>
<b class="nc">&nbsp;      .collect(Collectors.toList());</b>
&nbsp;  }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-02-17 23:45</div>
</div>
</body>
</html>
