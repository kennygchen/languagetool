


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > RuleMatch</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.languagetool.rules</a>
</div>

<h1>Coverage Summary for Class: RuleMatch (org.languagetool.rules)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">RuleMatch</td>
<td class="coverageStat">
  <span class="percent">
    78.5%
  </span>
  <span class="absValue">
    (51/65)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    38.5%
  </span>
  <span class="absValue">
    (30/78)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    78.2%
  </span>
  <span class="absValue">
    (133/170)
  </span>
</td>
</tr>
  <tr>
    <td class="name">RuleMatch$ColumnPosition</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">RuleMatch$LinePosition</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">RuleMatch$OffsetPosition</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">RuleMatch$PatternPosition</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">RuleMatch$SentencePosition</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">RuleMatch$Type</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    80.6%
  </span>
  <span class="absValue">
    (58/72)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    38.5%
  </span>
  <span class="absValue">
    (30/78)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    79.3%
  </span>
  <span class="absValue">
    (142/179)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/* LanguageTool, a natural language style checker 
&nbsp; * Copyright (C) 2005 Daniel Naber (http://www.danielnaber.de)
&nbsp; * 
&nbsp; * This library is free software; you can redistribute it and/or
&nbsp; * modify it under the terms of the GNU Lesser General Public
&nbsp; * License as published by the Free Software Foundation; either
&nbsp; * version 2.1 of the License, or (at your option) any later version.
&nbsp; *
&nbsp; * This library is distributed in the hope that it will be useful,
&nbsp; * but WITHOUT ANY WARRANTY; without even the implied warranty of
&nbsp; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
&nbsp; * Lesser General Public License for more details.
&nbsp; *
&nbsp; * You should have received a copy of the GNU Lesser General Public
&nbsp; * License along with this library; if not, write to the Free Software
&nbsp; * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
&nbsp; * USA
&nbsp; */
&nbsp;package org.languagetool.rules;
&nbsp;
&nbsp;import com.google.common.base.Suppliers;
&nbsp;import com.google.common.collect.Iterables;
&nbsp;import com.google.common.collect.Lists;
&nbsp;import org.jetbrains.annotations.NotNull;
&nbsp;import org.jetbrains.annotations.Nullable;
&nbsp;import org.languagetool.AnalyzedSentence;
&nbsp;import org.languagetool.ApiCleanupNeeded;
&nbsp;import org.languagetool.rules.patterns.PatternRule;
&nbsp;import org.languagetool.rules.patterns.PatternRuleMatcher;
&nbsp;import org.languagetool.tools.StringTools;
&nbsp;
&nbsp;import java.net.URL;
&nbsp;import java.util.*;
&nbsp;import java.util.function.Supplier;
&nbsp;import java.util.stream.Collectors;
&nbsp;
&nbsp;/**
&nbsp; * Information about an error rule that matches text and the position of the match.
&nbsp; * See {@link org.languagetool.tools.ContextTools} for displaying errors in their original text context.
&nbsp; * 
&nbsp; * @author Daniel Naber
&nbsp; */
&nbsp;public class RuleMatch implements Comparable&lt;RuleMatch&gt; {
<b class="fc">&nbsp;  public static final RuleMatch[] EMPTY_ARRAY = new RuleMatch[0];</b>
&nbsp;  public static final String SUGGESTION_START_TAG = &quot;&lt;suggestion&gt;&quot;;
&nbsp;  public static final String SUGGESTION_END_TAG = &quot;&lt;/suggestion&gt;&quot;;
&nbsp;
&nbsp;  //private static final Pattern SUGGESTION_PATTERN = Pattern.compile(&quot;&lt;suggestion&gt;(.*?)&lt;/suggestion&gt;&quot;);
&nbsp;  private final Rule rule;
&nbsp;  private String message;
&nbsp;  private String shortMessage;   // used e.g. for OOo/LO context menu
&nbsp;  private final AnalyzedSentence sentence;
&nbsp;
&nbsp;  private PatternPosition patternPosition;
&nbsp;  private OffsetPosition offsetPosition;
&nbsp;  // Position from the sentence start, to keep this value
&nbsp;  // when the offsetPosition is adjusted with JLanguageTool.adjustRuleMatchPos()
<b class="fc">&nbsp;  private SentencePosition sentencePosition = new SentencePosition(-1, -1);</b>
<b class="fc">&nbsp;  private LinePosition linePosition = new LinePosition(-1, -1);</b>
<b class="fc">&nbsp;  private ColumnPosition columnPosition = new ColumnPosition(-1, -1);</b>
&nbsp;  private Supplier&lt;List&lt;SuggestedReplacement&gt;&gt; suggestedReplacements;
&nbsp;  // track if more work needs to be done to compute suggestions;
&nbsp;  // allows enforcement of timeouts to return partial results without spending more time
<b class="fc">&nbsp;  private boolean suggestionsComputed = true;</b>
&nbsp;  private URL url;
<b class="fc">&nbsp;  private Type type = Type.Other;</b>
<b class="fc">&nbsp;  private SortedMap&lt;String, Float&gt; features = Collections.emptySortedMap();</b>
<b class="fc">&nbsp;  private boolean autoCorrect = false;</b>
<b class="fc">&nbsp;  private Map&lt;String, Float&gt; newLanguageMatches = new LinkedHashMap&lt;&gt;();</b>
&nbsp;
<b class="fc">&nbsp;  private String specificRuleId = &quot;&quot;;</b>
&nbsp;
&nbsp;  // the underlined error in the original sentence
<b class="fc">&nbsp;  private String originalErrorStr = &quot;&quot;;</b>
&nbsp;
&nbsp;  /**
&nbsp;   * Creates a RuleMatch object, taking the rule that triggered
&nbsp;   * this match, position of the match and an explanation message.
&nbsp;   * This message is scanned for &amp;lt;suggestion&amp;gt;...&amp;lt;/suggestion&amp;gt;
&nbsp;   * to get suggested fixes for the problem detected by this rule.
&nbsp;   *
&nbsp;   * @deprecated use a constructor that also takes an {@code AnalyzedSentence} parameter (deprecated since 4.0)
&nbsp;   */
&nbsp;  public RuleMatch(Rule rule, int fromPos, int toPos, String message) {
<b class="nc">&nbsp;    this(rule, fromPos, toPos, message, null, false, null);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Creates a RuleMatch object, taking the rule that triggered
&nbsp;   * this match, position of the match and an explanation message.
&nbsp;   * This message is scanned for &amp;lt;suggestion&amp;gt;...&amp;lt;/suggestion&amp;gt;
&nbsp;   * to get suggested fixes for the problem detected by this rule.
&nbsp;   *
&nbsp;   * @since 4.0
&nbsp;   */
&nbsp;  public RuleMatch(Rule rule, AnalyzedSentence sentence, int fromPos, int toPos, String message) {
<b class="fc">&nbsp;    this(rule, sentence, fromPos, toPos, fromPos, toPos, message, null, false, false, null, false);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Creates a RuleMatch object, taking the rule that triggered
&nbsp;   * this match, position of the match and an explanation message.
&nbsp;   * This message is scanned for &amp;lt;suggestion&amp;gt;...&amp;lt;/suggestion&amp;gt;
&nbsp;   * to get suggested fixes for the problem detected by this rule.
&nbsp;   *
&nbsp;   * @param shortMessage used for example in OpenOffice/LibreOffice&#39;s context menu
&nbsp;   * @since 4.0
&nbsp;   */
&nbsp;  public RuleMatch(Rule rule, AnalyzedSentence sentence, int fromPos, int toPos, String message, String shortMessage) {
<b class="fc">&nbsp;    this(rule, sentence, fromPos, toPos, fromPos, toPos, message, shortMessage, false, false, null, false);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Creates a RuleMatch object, taking the rule that triggered
&nbsp;   * this match, position of the match and an explanation message.
&nbsp;   * This message is scanned for &amp;lt;suggestion&amp;gt;...&amp;lt;/suggestion&amp;gt;
&nbsp;   * to get suggested fixes for the problem detected by this rule.
&nbsp;   *
&nbsp;   * @param shortMessage used for example in OpenOffice/LibreOffice&#39;s context menu
&nbsp;   * @since 4.9
&nbsp;   */
&nbsp;  public RuleMatch(Rule rule, AnalyzedSentence sentence, int fromPos, int toPos, int patternStartPos, int patternEndPos, String message, String shortMessage) {
<b class="fc">&nbsp;    this(rule, sentence, fromPos, toPos, patternStartPos, patternEndPos, message, shortMessage, false, false, null, false);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Create a rule match with any suggestions in the message overridden by the given suggestions
&nbsp;   *
&nbsp;   * @since 4.7
&nbsp;   */
&nbsp;  public RuleMatch(Rule rule, AnalyzedSentence sentence, int fromPos, int toPos, String message, String shortMessage, List&lt;String&gt; suggestions) {
<b class="nc">&nbsp;    this(rule, sentence, fromPos, toPos, fromPos, toPos, message, shortMessage, false, false, null, false);</b>
<b class="nc">&nbsp;    setSuggestedReplacements(suggestions);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * @deprecated use a constructor that also takes an {@code AnalyzedSentence} parameter (deprecated since 4.0)
&nbsp;   */
&nbsp;  public RuleMatch(Rule rule, int fromPos, int toPos, String message, String shortMessage,
&nbsp;                   boolean startWithUppercase, String suggestionsOutMsg) {
<b class="nc">&nbsp;    this(rule, null, fromPos, toPos, fromPos, toPos, message, shortMessage, startWithUppercase, false, suggestionsOutMsg, false);</b>
&nbsp;  }
&nbsp;
&nbsp;  public RuleMatch(Rule rule, AnalyzedSentence sentence, int fromPos, int toPos, int patternFromPos, int patternToPos,
&nbsp;                   String message, String shortMessage, boolean startWithUppercase, String suggestionsOutMsg) {
<b class="nc">&nbsp;    this(rule, sentence, fromPos, toPos, fromPos, toPos, message, shortMessage, startWithUppercase, false, suggestionsOutMsg, false);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Creates a RuleMatch object, taking the rule that triggered
&nbsp;   * this match, position of the match and an explanation message.
&nbsp;   * This message is scanned for &amp;lt;suggestion&amp;gt;...&amp;lt;/suggestion&amp;gt;
&nbsp;   * to get suggested fixes for the problem detected by this rule.
&nbsp;   *
&nbsp;   * @param fromPos            error start position in original text
&nbsp;   * @param toPos              error end position in original text
&nbsp;   * @param shortMessage       used for example in OpenOffice/LibreOffice&#39;s context menu (may be null)
&nbsp;   * @param startWithUppercase whether the original text at the position
&nbsp;   *                           of the match starts with an uppercase character
&nbsp;   * @since 4.0
&nbsp;   */
&nbsp;  public RuleMatch(Rule rule, AnalyzedSentence sentence, int fromPos, int toPos, int patternFromPos, int patternToPos,
&nbsp;                   String message, String shortMessage, boolean startWithUppercase, boolean isAllUppercase, String suggestionsOutMsg,
<b class="fc">&nbsp;                   boolean setOriginalErrorStr) {</b>
<b class="fc">&nbsp;    this.rule = Objects.requireNonNull(rule);</b>
<b class="pc">&nbsp;    if (toPos &lt;= fromPos) {</b>
<b class="nc">&nbsp;      throw new IllegalArgumentException(&quot;fromPos (&quot; + fromPos + &quot;) must be less than toPos (&quot; + toPos + &quot;)&quot;);</b>
&nbsp;    }
<b class="fc">&nbsp;    this.patternPosition = new PatternPosition(patternFromPos, patternToPos);</b>
<b class="fc">&nbsp;    this.offsetPosition = new OffsetPosition(fromPos, toPos);</b>
<b class="fc">&nbsp;    this.message = Objects.requireNonNull(message);</b>
<b class="fc">&nbsp;    this.shortMessage = shortMessage;</b>
<b class="fc">&nbsp;    this.sentence = sentence;</b>
<b class="fc">&nbsp;    if (setOriginalErrorStr) {</b>
<b class="fc">&nbsp;      this.setOriginalErrorStr();</b>
&nbsp;    }
&nbsp;    // extract suggestion from &lt;suggestion&gt;...&lt;/suggestion&gt; in message:
<b class="fc">&nbsp;    LinkedHashSet&lt;SuggestedReplacement&gt; replacements = new LinkedHashSet&lt;&gt;();</b>
<b class="fc">&nbsp;    String suggestion = message + (suggestionsOutMsg != null ? suggestionsOutMsg : &quot;&quot;);</b>
<b class="fc">&nbsp;    int pos = suggestion.indexOf(SUGGESTION_START_TAG);</b>
<b class="fc">&nbsp;    while (pos != -1) {</b>
<b class="fc">&nbsp;      int end = suggestion.indexOf(SUGGESTION_END_TAG, pos);</b>
<b class="pc">&nbsp;      if (end == -1) {</b>
&nbsp;        break;
&nbsp;      }
<b class="fc">&nbsp;      String replacement = suggestion.substring(pos + SUGGESTION_START_TAG.length(), end);</b>
<b class="fc">&nbsp;      pos = end + SUGGESTION_END_TAG.length();</b>
<b class="pc">&nbsp;      if (replacement.contains(PatternRuleMatcher.MISTAKE)) {</b>
&nbsp;        continue;
&nbsp;      }
&nbsp;      // ignore single words in mixed case
<b class="pc">&nbsp;      if (isAllUppercase &amp;&amp; !(StringTools.isMixedCase(replacement) &amp;&amp; !replacement.contains(&quot; &quot;))) {</b>
&nbsp;        // do not create a suggestion equal to the input string
<b class="nc">&nbsp;        if (!getOriginalErrorStr().equals(replacement.toUpperCase())) {</b>
<b class="nc">&nbsp;          replacement = replacement.toUpperCase();</b>
&nbsp;        }
<b class="fc">&nbsp;      } else if (startWithUppercase) {</b>
<b class="fc">&nbsp;        replacement = StringTools.uppercaseFirstChar(replacement);</b>
&nbsp;      }
<b class="fc">&nbsp;      replacements.add(new SuggestedReplacement(replacement));</b>
<b class="fc">&nbsp;      pos = suggestion.indexOf(SUGGESTION_START_TAG, pos);</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    suggestedReplacements = Suppliers.ofInstance(new ArrayList&lt;&gt;(replacements));</b>
&nbsp;  }
&nbsp;
&nbsp;  @SuppressWarnings(&quot;CopyConstructorMissesField&quot;)
<b class="fc">&nbsp;  public RuleMatch(RuleMatch clone) {</b>
<b class="fc">&nbsp;    this.rule = clone.getRule();</b>
<b class="fc">&nbsp;    this.sentence = clone.getSentence();</b>
<b class="fc">&nbsp;    this.setOffsetPosition(clone.getFromPos(), clone.getToPos());</b>
<b class="fc">&nbsp;    this.message = clone.getMessage();</b>
<b class="fc">&nbsp;    this.shortMessage = clone.getShortMessage();</b>
<b class="fc">&nbsp;    this.setPatternPosition(clone.getPatternFromPos(), clone.getPatternToPos());</b>
<b class="fc">&nbsp;    this.suggestedReplacements = clone.suggestedReplacements;</b>
<b class="fc">&nbsp;    this.setAutoCorrect(clone.isAutoCorrect());</b>
<b class="fc">&nbsp;    this.setFeatures(clone.getFeatures());</b>
<b class="fc">&nbsp;    this.setUrl(clone.getUrl());</b>
<b class="fc">&nbsp;    this.setType(clone.getType());</b>
<b class="fc">&nbsp;    this.setLine(clone.getLine());</b>
<b class="fc">&nbsp;    this.setEndLine(clone.getEndLine());</b>
<b class="fc">&nbsp;    this.setColumn(clone.getColumn());</b>
<b class="fc">&nbsp;    this.setEndColumn(clone.getEndColumn());</b>
<b class="fc">&nbsp;    this.setSpecificRuleId(clone.getSpecificRuleId());</b>
<b class="fc">&nbsp;    this.setOriginalErrorStr(clone.getOriginalErrorStr());</b>
<b class="fc">&nbsp;    this.setSentencePosition(clone.getFromPosSentence(), clone.getToPosSentence());</b>
&nbsp;  }
&nbsp;
&nbsp;  //clone with new replacements
&nbsp;  public RuleMatch(RuleMatch clone, List&lt;SuggestedReplacement&gt; replacements, boolean ignored) {
<b class="fc">&nbsp;    this(clone);</b>
<b class="fc">&nbsp;    this.setSuggestedReplacementObjects(replacements);</b>
&nbsp;    // &quot;ignored&quot; is unused?
&nbsp;  }
&nbsp;
&nbsp;  // for compatibility
&nbsp;  public RuleMatch(RuleMatch clone, List&lt;SuggestedReplacement&gt; replacements) {
<b class="fc">&nbsp;    this(clone, replacements, false);</b>
&nbsp;  }
&nbsp;
&nbsp;  @NotNull
&nbsp;  public SortedMap&lt;String, Float&gt; getFeatures() {
<b class="fc">&nbsp;    return features;</b>
&nbsp;  }
&nbsp;
&nbsp;  public void setFeatures(@NotNull SortedMap&lt;String, Float&gt; features) {
<b class="fc">&nbsp;    this.features = features;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isAutoCorrect() {
<b class="fc">&nbsp;    return autoCorrect;</b>
&nbsp;  }
&nbsp;
&nbsp;  public void setAutoCorrect(boolean autoCorrect) {
<b class="fc">&nbsp;    this.autoCorrect = autoCorrect;</b>
&nbsp;  }
&nbsp;
&nbsp;  public Rule getRule() {
<b class="fc">&nbsp;    return rule;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Get the line number in which the match occurs (zero-based).
&nbsp;   *
&nbsp;   * @deprecated rely on the character-based {@link #getFromPos()} instead (deprecated since 3.4)
&nbsp;   */
&nbsp;  public int getLine() {
<b class="fc">&nbsp;    return linePosition.getStart();</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Set the line number in which the match occurs (zero-based).
&nbsp;   */
&nbsp;  public void setLine(int fromLine) {
<b class="fc">&nbsp;    linePosition = new LinePosition(fromLine, linePosition.getEnd());</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Get the line number in which the match ends (zero-based).
&nbsp;   *
&nbsp;   * @deprecated rely on {@link #getToPos()} instead (deprecated since 3.4)
&nbsp;   */
&nbsp;  public int getEndLine() {
<b class="fc">&nbsp;    return linePosition.getEnd();</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Set the line number in which the match ends (zero-based).
&nbsp;   */
&nbsp;  public void setEndLine(int endLine) {
<b class="fc">&nbsp;    linePosition = new LinePosition(linePosition.getStart(), endLine);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Get the column number in which the match occurs (zero-based).
&nbsp;   *
&nbsp;   * @deprecated rely on the character-based {@link #getFromPos()} instead (deprecated since 3.4)
&nbsp;   */
&nbsp;  public int getColumn() {
<b class="fc">&nbsp;    return columnPosition.getStart();</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Set the column number in which the match occurs (zero-based).
&nbsp;   *
&nbsp;   * @deprecated (deprecated since 3.5)
&nbsp;   */
&nbsp;  public void setColumn(int column) {
<b class="fc">&nbsp;    this.columnPosition = new ColumnPosition(column, columnPosition.getEnd());</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Get the column number in which the match ends (zero-based).
&nbsp;   *
&nbsp;   * @deprecated rely on {@link #getToPos()} instead (deprecated since 3.4)
&nbsp;   */
&nbsp;  public int getEndColumn() {
<b class="fc">&nbsp;    return columnPosition.getEnd();</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Set the column number in which the match ends (zero-based).
&nbsp;   *
&nbsp;   * @deprecated (deprecated since 3.5)
&nbsp;   */
&nbsp;  public void setEndColumn(int endColumn) {
<b class="fc">&nbsp;    this.columnPosition = new ColumnPosition(columnPosition.getStart(), endColumn);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Position of the start of the pattern (in characters, zero-based, relative to the original input text).
&nbsp;   */
&nbsp;  public int getPatternFromPos() {
<b class="fc">&nbsp;    return patternPosition.getStart();</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Position of the end of the mistake pattern (in characters, zero-based, relative to the original input text).
&nbsp;   */
&nbsp;  public int getPatternToPos() {
<b class="fc">&nbsp;    return patternPosition.getEnd();</b>
&nbsp;  }
&nbsp;
&nbsp;  public void setPatternPosition(int fromPos, int toPos) {
<b class="pc">&nbsp;    if (toPos &lt;= fromPos) {</b>
<b class="nc">&nbsp;      throw new RuntimeException(&quot;fromPos (&quot; + fromPos + &quot;) must be less than toPos (&quot; + toPos + &quot;)&quot;);</b>
&nbsp;    }
<b class="fc">&nbsp;    patternPosition = new PatternPosition(fromPos, toPos);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Position of the start of the error (in characters, zero-based, relative to the original input text).
&nbsp;   */
&nbsp;  public int getFromPos() {
<b class="fc">&nbsp;    return offsetPosition.getStart();</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Position of the end of the error (in characters, zero-based, relative to the original input text).
&nbsp;   */
&nbsp;  public int getToPos() {
<b class="fc">&nbsp;    return offsetPosition.getEnd();</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Position of the start of the error (in characters, zero-based, relative to the original sentence).
&nbsp;   * This value is used to keep the position in the sentence when the offsetPosition is adjusted to the whole text
&nbsp;   */
&nbsp;  public int getFromPosSentence() {
<b class="fc">&nbsp;    return sentencePosition.getStart();</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Position of the end of the error (in characters, zero-based, relative to the original sentence).
&nbsp;   * This value is used to keep the position in the sentence when the offsetPosition is adjusted to the whole text
&nbsp;   */
&nbsp;  public int getToPosSentence() {
<b class="fc">&nbsp;    return sentencePosition.getEnd();</b>
&nbsp;  }
&nbsp;
&nbsp;  public void setOffsetPosition(int fromPos, int toPos) {
<b class="pc">&nbsp;    if (toPos &lt;= fromPos) {</b>
<b class="nc">&nbsp;      throw new RuntimeException(&quot;fromPos (&quot; + fromPos + &quot;) must be less than toPos (&quot; + toPos + &quot;) for match: &lt;sentcontent&gt;&quot; + this + &quot;&lt;/sentcontent&gt;&quot;);</b>
&nbsp;    }
<b class="fc">&nbsp;    offsetPosition = new OffsetPosition(fromPos, toPos);</b>
&nbsp;  }
&nbsp;
&nbsp;  public void setSentencePosition(int fromPos, int toPos) {
<b class="pc">&nbsp;    if (toPos &gt; -1 &amp;&amp; fromPos &gt; -1 &amp;&amp; toPos &lt;= fromPos) {</b>
<b class="nc">&nbsp;      throw new RuntimeException(&quot;fromPos (&quot; + fromPos + &quot;) must be less than toPos (&quot; + toPos + &quot;) for match: &lt;sentcontent&gt;&quot; + this + &quot;&lt;/sentcontent&gt;&quot;);</b>
&nbsp;    }
<b class="fc">&nbsp;    sentencePosition = new SentencePosition(fromPos, toPos);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * A human-readable explanation describing the error. This may contain
&nbsp;   * one or more corrections marked up with &amp;lt;suggestion&amp;gt;...&amp;lt;/suggestion&amp;gt;.
&nbsp;   *
&nbsp;   * @see #getSuggestedReplacements()
&nbsp;   * @see #getShortMessage()
&nbsp;   */
&nbsp;  public String getMessage() {
<b class="fc">&nbsp;    return message;</b>
&nbsp;  }
&nbsp;
&nbsp;  public void setMessage(String msg) {
<b class="nc">&nbsp;    message = msg;</b>
&nbsp;  }
&nbsp;  /**
&nbsp;   * A shorter human-readable explanation describing the error or an empty string
&nbsp;   * if no such explanation is available.
&nbsp;   *
&nbsp;   * @see #getMessage()
&nbsp;   */
&nbsp;  @ApiCleanupNeeded(&quot;Should return an Optional&quot;)
&nbsp;  public String getShortMessage() {
<b class="fc">&nbsp;    if (shortMessage == null) {</b>
<b class="fc">&nbsp;      return &quot;&quot;;  // just because this is what we have documented</b>
&nbsp;    }
<b class="fc">&nbsp;    return shortMessage;</b>
&nbsp;  }
&nbsp;
&nbsp;  public void setShortMessage(String msg) {
<b class="fc">&nbsp;    shortMessage = msg;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * @see #getSuggestedReplacements()
&nbsp;   */
&nbsp;  public void setSuggestedReplacement(String replacement) {
<b class="fc">&nbsp;    Objects.requireNonNull(replacement, &quot;replacement may be empty but not null&quot;);</b>
<b class="fc">&nbsp;    List&lt;String&gt; replacements = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;    replacements.add(replacement);</b>
<b class="fc">&nbsp;    setSuggestedReplacements(replacements);</b>
&nbsp;  }
&nbsp;
&nbsp;  public void addSuggestedReplacement(String replacement) {
<b class="nc">&nbsp;    Objects.requireNonNull(replacement, &quot;replacement may be empty but not null&quot;);</b>
<b class="nc">&nbsp;    addSuggestedReplacements(Collections.singletonList(replacement));</b>
&nbsp;  }
&nbsp;
&nbsp;  public void addSuggestedReplacements(List&lt;String&gt; replacements) {
<b class="nc">&nbsp;    Objects.requireNonNull(replacements, &quot;replacements may be empty but not null&quot;);</b>
<b class="nc">&nbsp;    Supplier&lt;List&lt;SuggestedReplacement&gt;&gt; prev = suggestedReplacements;</b>
<b class="nc">&nbsp;    setLazySuggestedReplacements(() -&gt;</b>
<b class="nc">&nbsp;      Lists.newArrayList(Iterables.concat(prev.get(), Iterables.transform(replacements, SuggestedReplacement::new))));</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * The text fragments which might be an appropriate fix for the problem. One
&nbsp;   * of these fragments can be used to replace the old text between {@link #getFromPos()}
&nbsp;   * to {@link #getToPos()}.
&nbsp;   *
&nbsp;   * @return unmodifiable list of String objects or an empty List
&nbsp;   */
&nbsp;  public List&lt;String&gt; getSuggestedReplacements() {
<b class="fc">&nbsp;    return Collections.unmodifiableList(</b>
<b class="fc">&nbsp;      suggestedReplacements.get().stream().map(SuggestedReplacement::getReplacement).collect(Collectors.toList())</b>
&nbsp;    );
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * @see #getSuggestedReplacements()
&nbsp;   */
&nbsp;  public void setSuggestedReplacements(List&lt;String&gt; replacements) {
<b class="fc">&nbsp;    Objects.requireNonNull(replacements, &quot;replacements may be empty but not null&quot;);</b>
<b class="fc">&nbsp;    suggestionsComputed = true;</b>
<b class="fc">&nbsp;    suggestedReplacements = Suppliers.ofInstance(</b>
<b class="fc">&nbsp;      replacements.stream().map(SuggestedReplacement::new).collect(Collectors.toList())</b>
&nbsp;    );
&nbsp;  }
&nbsp;
&nbsp;  public List&lt;SuggestedReplacement&gt; getSuggestedReplacementObjects() {
<b class="fc">&nbsp;    return Collections.unmodifiableList(suggestedReplacements.get());</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * @see #getSuggestedReplacements()
&nbsp;   */
&nbsp;  public void setSuggestedReplacementObjects(List&lt;SuggestedReplacement&gt; replacements) {
<b class="fc">&nbsp;    Objects.requireNonNull(replacements, &quot;replacements may be empty but not null&quot;);</b>
<b class="fc">&nbsp;    suggestedReplacements = Suppliers.ofInstance(replacements);</b>
<b class="fc">&nbsp;    suggestionsComputed = true;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Set a lazy supplier that will compute suggested replacements
&nbsp;   * when {@link #getSuggestedReplacements()} or {@link #getSuggestedReplacementObjects()} is called.
&nbsp;   * This can be used to speed up sentence analysis
&nbsp;   * in cases when computationally expensive replacements won&#39;t necessarily be needed
&nbsp;   * (e.g. for an IDE in the same process).
&nbsp;   */
&nbsp;  public void setLazySuggestedReplacements(@NotNull Supplier&lt;List&lt;SuggestedReplacement&gt;&gt; replacements) {
<b class="fc">&nbsp;    Objects.requireNonNull(replacements, &quot;replacements may not be null&quot;);</b>
<b class="fc">&nbsp;    suggestedReplacements = Suppliers.memoize(replacements::get);</b>
<b class="fc">&nbsp;    suggestionsComputed = false;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Force computing replacements, e.g. for accurate metrics for computation time and to set timeouts for this process
&nbsp;   * Used in server use case (i.e. {@code org.languagetool.server.TextChecker})
&nbsp;   */
&nbsp;  public void computeLazySuggestedReplacements() {
<b class="nc">&nbsp;    suggestedReplacements = Suppliers.ofInstance(suggestedReplacements.get());</b>
<b class="nc">&nbsp;    suggestionsComputed = true;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Discard lazy suggested replacements, but keep other suggestions
&nbsp;   * Useful to enforce time limits on result computation
&nbsp;   */
&nbsp;  public void discardLazySuggestedReplacements() {
<b class="nc">&nbsp;    if (!suggestionsComputed) {</b>
<b class="nc">&nbsp;      setSuggestedReplacementObjects(Collections.emptyList());</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * A URL that points to a more detailed error description or {@code null}.
&nbsp;   * Note that the {@link Rule} itself might also have an URL, which is usually
&nbsp;   * a less specific one than this. This one will overwrite the rule&#39;s URL in
&nbsp;   * the JSON output.
&nbsp;   *
&nbsp;   * @since 4.0
&nbsp;   */
&nbsp;  @Nullable
&nbsp;  public URL getUrl() {
<b class="fc">&nbsp;    return url;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * @since 4.0
&nbsp;   */
&nbsp;  public void setUrl(URL url) {
<b class="fc">&nbsp;    this.url = url;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * @since 4.0
&nbsp;   */
&nbsp;  public AnalyzedSentence getSentence() {
<b class="fc">&nbsp;    return sentence;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * @since 4.3
&nbsp;   */
&nbsp;  public Type getType() {
<b class="fc">&nbsp;    return this.type;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * @since 4.3
&nbsp;   */
&nbsp;  public void setType(Type type) {
<b class="fc">&nbsp;    this.type = Objects.requireNonNull(type);</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public String toString() {
<b class="nc">&nbsp;    if (rule instanceof PatternRule) {</b>
&nbsp;      //String covered = getSentence().getText().substring(getFromPos(), getToPos());
&nbsp;      //return ((PatternRule) rule).getFullId() + &quot;:&quot; + offsetPosition + &quot;:&quot; + message + &quot;:&quot; + covered + &quot; -&gt; &quot; + getSuggestedReplacements();
<b class="nc">&nbsp;      return rule.getFullId() + &quot;:&quot; + offsetPosition + &quot;:&quot; + message;</b>
&nbsp;    } else {
&nbsp;      //String covered = getSentence().getText().substring(getFromPos(), getToPos());
&nbsp;      //return rule.getId() + &quot;:&quot; + offsetPosition + &quot;:&quot; + message + &quot;:&quot; + covered + &quot; -&gt; &quot; + getSuggestedReplacements();
<b class="nc">&nbsp;      return rule.getId() + &quot;:&quot; + offsetPosition + &quot;:&quot; + message;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Compare by start position.
&nbsp;   */
&nbsp;  @Override
&nbsp;  public int compareTo(RuleMatch other) {
<b class="fc">&nbsp;    Objects.requireNonNull(other);</b>
<b class="fc">&nbsp;    return Integer.compare(getFromPos(), other.getFromPos());</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public boolean equals(Object o) {
<b class="nc">&nbsp;    if (this == o) return true;</b>
<b class="nc">&nbsp;    if (o == null || getClass() != o.getClass()) return false;</b>
<b class="nc">&nbsp;    RuleMatch other = (RuleMatch) o;</b>
<b class="nc">&nbsp;    return Objects.equals(rule.getId(), other.rule.getId())</b>
<b class="nc">&nbsp;      &amp;&amp; Objects.equals(patternPosition, other.patternPosition)</b>
<b class="nc">&nbsp;      &amp;&amp; Objects.equals(offsetPosition, other.offsetPosition)</b>
<b class="nc">&nbsp;      &amp;&amp; Objects.equals(message, other.message)</b>
<b class="nc">&nbsp;      &amp;&amp; Objects.equals(sentence, other.sentence)</b>
<b class="nc">&nbsp;      &amp;&amp; Objects.equals(type, other.type);</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public int hashCode() {
<b class="nc">&nbsp;    return Objects.hash(rule.getId(), offsetPosition, patternPosition, message, sentence, type);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * The language that the text might be in if the error limit has been reached.
&nbsp;   *
&nbsp;   * @since 6.4
&nbsp;   */
&nbsp;  public Map&lt;String, Float&gt; getNewLanguageMatches() {
<b class="fc">&nbsp;    return newLanguageMatches;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Call if the error limit is reached for this sentence. The caller will then get text ranges for the
&nbsp;   * sentence and can ignore errors there. Note: will not have an effect for text-level rules.
&nbsp;   *
&nbsp;   * @param newLanguageMatches a map of possible languages this could be instead
&nbsp;   * @since 6.4
&nbsp;   */
&nbsp;  public void setNewLanguageMatches(Map&lt;String, Float&gt; newLanguageMatches) {
<b class="nc">&nbsp;    this.newLanguageMatches = newLanguageMatches;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Unlike {@link Category}, this is specific to a RuleMatch, not to a rule.
&nbsp;   * It is mainly used for selecting the underline color in clients.
&nbsp;   * Note: this is experimental and might change soon (types might be added, deleted or renamed
&nbsp;   * without deprecating them first)
&nbsp;   *
&nbsp;   * @since 4.3
&nbsp;   */
<b class="fc">&nbsp;  public enum Type {</b>
&nbsp;    /**
&nbsp;     * Spelling errors, typically red.
&nbsp;     */
<b class="fc">&nbsp;    UnknownWord,</b>
&nbsp;    /**
&nbsp;     * Style errors, typically light blue.
&nbsp;     */
<b class="fc">&nbsp;    Hint,</b>
&nbsp;    /**
&nbsp;     * Other errors (including grammar), typically yellow/orange.
&nbsp;     */
<b class="fc">&nbsp;    Other</b>
&nbsp;  }
&nbsp;
&nbsp;  static class PatternPosition extends MatchPosition {
&nbsp;    PatternPosition(int start, int end) {
<b class="fc">&nbsp;      super(start, end);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  static class OffsetPosition extends MatchPosition {
&nbsp;    OffsetPosition(int start, int end) {
<b class="fc">&nbsp;      super(start, end);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  static class SentencePosition extends MatchPosition {
&nbsp;    SentencePosition(int start, int end) {
<b class="fc">&nbsp;      super(start, end);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  static class LinePosition extends MatchPosition {
&nbsp;    LinePosition(int start, int end) {
<b class="fc">&nbsp;      super(start, end);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  static class ColumnPosition extends MatchPosition {
&nbsp;    ColumnPosition(int start, int end) {
<b class="fc">&nbsp;      super(start, end);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Set a new specific rule ID in the RuleMatch to replace getRule().getId() in
&nbsp;   * the output. Used for statistical purposes.
&nbsp;   *
&nbsp;   * @since 5.6
&nbsp;   */
&nbsp;  public void setSpecificRuleId(String ruleId) {
<b class="fc">&nbsp;    specificRuleId = ruleId;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Get the specific rule ID from the RuleMatch to replace getRule().getId() in
&nbsp;   * the output. Used for statistical purposes.
&nbsp;   *
&nbsp;   * @since 5.6
&nbsp;   */
&nbsp;  public String getSpecificRuleId() {
<b class="fc">&nbsp;    if (specificRuleId.isEmpty()) {</b>
<b class="fc">&nbsp;      return this.getRule().getId();</b>
&nbsp;    } else {
<b class="fc">&nbsp;      return specificRuleId;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  public void setOriginalErrorStr() {
<b class="pc">&nbsp;    if (!this.originalErrorStr.isEmpty()) {</b>
&nbsp;      return;
&nbsp;    }
<b class="pc">&nbsp;    if (this.getSentence() == null) {</b>
&nbsp;      return;
&nbsp;    }
<b class="fc">&nbsp;    String sentenceStr = this.getSentence().getText();</b>
<b class="pc">&nbsp;    if (sentenceStr.isEmpty()) {</b>
&nbsp;      return;
&nbsp;    }
&nbsp;    // use the positions in the sentence if available
<b class="fc">&nbsp;    int fromPos = this.getFromPosSentence();</b>
<b class="fc">&nbsp;    int toPos = this.getToPosSentence();</b>
<b class="pc">&nbsp;    if (fromPos &gt; -1 &amp;&amp; toPos &gt; -1 &amp;&amp; toPos&lt;=sentenceStr.length() &amp;&amp; fromPos&lt;toPos) {</b>
<b class="nc">&nbsp;      this.originalErrorStr = sentenceStr.substring(fromPos, toPos);</b>
&nbsp;      return;
&nbsp;    }
&nbsp;    // otherwise use the positions before the offsetPosition is adjusted to the whole text
<b class="fc">&nbsp;    fromPos = this.getFromPos();</b>
<b class="fc">&nbsp;    toPos = this.getToPos();</b>
<b class="pc">&nbsp;    if (fromPos &gt; -1 &amp;&amp; toPos &gt; -1 &amp;&amp; toPos&lt;=sentenceStr.length() &amp;&amp; fromPos&lt;toPos) {</b>
<b class="fc">&nbsp;      this.originalErrorStr = sentenceStr.substring(fromPos, toPos);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * To store the underlined string in the original sentence.
&nbsp;   */
&nbsp;  public void setOriginalErrorStr(String originalErrorStr) {
<b class="fc">&nbsp;    this.originalErrorStr = originalErrorStr;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Get the underlined string in the original sentence.
&nbsp;   * Only available for sentence-level pattern rules.
&nbsp;   * Returns an empty string if not available.
&nbsp;   * For other rules, use setOriginalErrorStr(String originalErrorStr)
&nbsp;   * @since 6.3
&nbsp;   */
&nbsp;  public String getOriginalErrorStr() {
<b class="fc">&nbsp;    return this.originalErrorStr;</b>
&nbsp;  }
&nbsp;}
&nbsp;
&nbsp;
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-02-17 23:50</div>
</div>
</body>
</html>
