


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > StringMatcher</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.languagetool.rules.patterns</a>
</div>

<h1>Coverage Summary for Class: StringMatcher (org.languagetool.rules.patterns)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">StringMatcher</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (20/20)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (32/32)
  </span>
</td>
</tr>
  <tr>
    <td class="name">StringMatcher$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">StringMatcher$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">StringMatcher$3</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    87.5%
  </span>
  <span class="absValue">
    (7/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (6/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">StringMatcher$4</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">StringMatcher$5</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">StringMatcher$6</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">StringMatcher$RegexpParser</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    94.8%
  </span>
  <span class="absValue">
    (91/96)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (84/84)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">StringMatcher$TooComplexRegexp</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">StringMatcher$TooComplexRegexp$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (41/41)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    93.4%
  </span>
  <span class="absValue">
    (127/136)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    97.4%
  </span>
  <span class="absValue">
    (150/154)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/* LanguageTool, a natural language style checker
&nbsp; * Copyright (C) 2020 Peter Gromov
&nbsp; *
&nbsp; * This library is free software; you can redistribute it and/or
&nbsp; * modify it under the terms of the GNU Lesser General Public
&nbsp; * License as published by the Free Software Foundation; either
&nbsp; * version 2.1 of the License, or (at your option) any later version.
&nbsp; *
&nbsp; * This library is distributed in the hope that it will be useful,
&nbsp; * but WITHOUT ANY WARRANTY; without even the implied warranty of
&nbsp; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
&nbsp; * Lesser General Public License for more details.
&nbsp; *
&nbsp; * You should have received a copy of the GNU Lesser General Public
&nbsp; * License along with this library; if not, write to the Free Software
&nbsp; * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
&nbsp; * USA
&nbsp; */
&nbsp;package org.languagetool.rules.patterns;
&nbsp;
&nbsp;import com.google.common.annotations.VisibleForTesting;
&nbsp;import com.google.common.collect.Sets;
&nbsp;import org.jetbrains.annotations.NotNull;
&nbsp;import org.jetbrains.annotations.Nullable;
&nbsp;import org.languagetool.tools.InterruptibleCharSequence;
&nbsp;import org.languagetool.tools.StringInterner;
&nbsp;
&nbsp;import java.util.*;
&nbsp;import java.util.function.Function;
&nbsp;import java.util.regex.Pattern;
&nbsp;import java.util.stream.Collectors;
&nbsp;import java.util.stream.Stream;
&nbsp;
&nbsp;import static org.languagetool.tools.StringInterner.intern;
&nbsp;
&nbsp;/**
&nbsp; * An object encapsulating a text pattern and the way it&#39;s matched (case-sensitivity / regular expression),
&nbsp; * plus some optimizations over standard regular expression matching.
&nbsp; * @since 5.3
&nbsp; */
&nbsp;public abstract class StringMatcher {
&nbsp;  
&nbsp;  final String pattern;
&nbsp;  final boolean caseSensitive;
&nbsp;  final boolean isRegExp;
&nbsp;  
&nbsp;  public final static int MAX_MATCH_LENGTH = 250;
&nbsp;
<b class="fc">&nbsp;  private StringMatcher(String pattern, boolean isRegExp, boolean caseSensitive) {</b>
<b class="fc">&nbsp;    this.pattern = intern(pattern);</b>
<b class="fc">&nbsp;    this.caseSensitive = caseSensitive;</b>
<b class="fc">&nbsp;    this.isRegExp = isRegExp;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * @return all values that this matcher can possibly accept (e.g. extracted from regexps like &quot;foo|bar&quot;),
&nbsp;   * or {@code null} if it&#39;s not possible to determine those.
&nbsp;   */
&nbsp;  @Nullable
&nbsp;  public abstract Set&lt;String&gt; getPossibleValues();
&nbsp;
&nbsp;  /**
&nbsp;   * @return whether the given string is accepted by this matcher.
&nbsp;   */
&nbsp;  public abstract boolean matches(String s);
&nbsp;
&nbsp;  /**
&nbsp;   * Create a case-sensitive regexp matcher.
&nbsp;   * @since 5.6
&nbsp;   */
&nbsp;  public static StringMatcher regexp(String pattern) {
<b class="fc">&nbsp;    return create(pattern, true, true);</b>
&nbsp;  }
&nbsp;
&nbsp;  public static StringMatcher create(String pattern, boolean isRegExp, boolean caseSensitive) {
<b class="fc">&nbsp;    if (!isRegExp || &quot;\\0&quot;.equals(pattern)) {</b>
<b class="fc">&nbsp;      return stringEquals(pattern, isRegExp, caseSensitive);</b>
&nbsp;    }
&nbsp;
&nbsp;    // always compile the pattern to check it&#39;s well-formed
<b class="fc">&nbsp;    Pattern compiled = Pattern.compile(pattern, caseSensitive ? 0 : Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);</b>
&nbsp;
<b class="fc">&nbsp;    Set&lt;String&gt; possibleRegexpValues = getPossibleRegexpValues(pattern);</b>
<b class="fc">&nbsp;    if (possibleRegexpValues != null) {</b>
<b class="fc">&nbsp;      Set&lt;String&gt; set = possibleRegexpValues.stream().map(StringInterner::intern).collect(Collectors.toSet());</b>
<b class="fc">&nbsp;      if (set.size() == 1) {</b>
<b class="fc">&nbsp;        return stringEquals(set.iterator().next(), true, caseSensitive);</b>
&nbsp;      }
<b class="fc">&nbsp;      if (!caseSensitive) {</b>
<b class="fc">&nbsp;        String[] sorted = set.toArray(new String[0]);</b>
<b class="fc">&nbsp;        Arrays.sort(sorted, String.CASE_INSENSITIVE_ORDER);</b>
<b class="fc">&nbsp;        return new StringMatcher(pattern, true, false) {</b>
&nbsp;          @Override
&nbsp;          public Set&lt;String&gt; getPossibleValues() {
<b class="fc">&nbsp;            return Sets.newHashSet(sorted);</b>
&nbsp;          }
&nbsp;
&nbsp;          @Override
&nbsp;          public boolean matches(String s) {
<b class="pc">&nbsp;            if (s.length() &gt; MAX_MATCH_LENGTH) {</b>
<b class="nc">&nbsp;              return false;</b>
&nbsp;            }
<b class="fc">&nbsp;            return Arrays.binarySearch(sorted, s, String.CASE_INSENSITIVE_ORDER) &gt;= 0;</b>
&nbsp;          }
&nbsp;        };
&nbsp;      }
<b class="fc">&nbsp;      return new StringMatcher(pattern, true, true) {</b>
&nbsp;        @Override
&nbsp;        public Set&lt;String&gt; getPossibleValues() {
<b class="fc">&nbsp;          return Collections.unmodifiableSet(set);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean matches(String s) {
<b class="pc">&nbsp;          if (s.length() &gt; MAX_MATCH_LENGTH) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;          }
<b class="fc">&nbsp;          return set.contains(s);</b>
&nbsp;        }
&nbsp;      };
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    Substrings required = getRequiredSubstrings(pattern);</b>
<b class="fc">&nbsp;    Substrings exhaustive = required == null ? null : required.checkCanReplaceRegex(pattern);</b>
<b class="fc">&nbsp;    boolean substringsAreSufficient = exhaustive != null;</b>
<b class="fc">&nbsp;    Substrings substrings = substringsAreSufficient ? exhaustive : required;</b>
&nbsp;
<b class="fc">&nbsp;    return new StringMatcher(pattern, true, caseSensitive) {</b>
&nbsp;      @Nullable
&nbsp;      @Override
&nbsp;      public Set&lt;String&gt; getPossibleValues() {
<b class="fc">&nbsp;        return null;</b>
&nbsp;      }
&nbsp;
&nbsp;      @Override
&nbsp;      public boolean matches(String s) {
<b class="pc">&nbsp;        if (s.length() &gt; MAX_MATCH_LENGTH) {</b>
<b class="nc">&nbsp;          return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (substrings != null &amp;&amp; !substrings.matches(s, caseSensitive)) return false;</b>
<b class="fc">&nbsp;        if (substringsAreSufficient) return true;</b>
<b class="fc">&nbsp;        return compiled.matcher(new InterruptibleCharSequence(s)).matches();</b>
&nbsp;      }
&nbsp;    };
&nbsp;  }
&nbsp;
&nbsp;  @NotNull
&nbsp;  private static StringMatcher stringEquals(String pattern, final boolean isRegExp, boolean caseSensitive) {
<b class="fc">&nbsp;    return new StringMatcher(pattern, isRegExp, caseSensitive) {</b>
&nbsp;      @Override
&nbsp;      public Set&lt;String&gt; getPossibleValues() {
<b class="fc">&nbsp;        return Collections.singleton(pattern);</b>
&nbsp;      }
&nbsp;
&nbsp;      @Override
&nbsp;      public boolean matches(String s) {
<b class="pc">&nbsp;        if (s.length() &gt; MAX_MATCH_LENGTH) {</b>
<b class="nc">&nbsp;          return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        return caseSensitive ? s.equals(pattern) : s.equalsIgnoreCase(pattern);</b>
&nbsp;      }
&nbsp;    };
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * @return the substrings that any text would necessarily contain or start/end with if it matches the given regexp,
&nbsp;   * or {@code null} if no such substrings can be found
&nbsp;   */
&nbsp;  @Nullable
&nbsp;  static Substrings getRequiredSubstrings(String regexp) {
<b class="fc">&nbsp;    Substrings UNKNOWN = new Substrings(false, false, new String[0]);</b>
&nbsp;
<b class="fc">&nbsp;    RegexpParser&lt;Substrings&gt; parser = new RegexpParser&lt;Substrings&gt;(regexp) {</b>
&nbsp;      @Override
&nbsp;      Substrings handleConcatenation(Substrings left, Substrings right) {
<b class="fc">&nbsp;        return left.concat(right);</b>
&nbsp;      }
&nbsp;
&nbsp;      @Override
&nbsp;      Substrings handleOr(List&lt;Substrings&gt; components) {
<b class="fc">&nbsp;        return UNKNOWN;</b>
&nbsp;      }
&nbsp;
&nbsp;      @Override
&nbsp;      protected Substrings optional(Substrings groupResults, char op) {
<b class="fc">&nbsp;        return UNKNOWN;</b>
&nbsp;      }
&nbsp;
&nbsp;      @Override
&nbsp;      protected Substrings unknown() {
<b class="fc">&nbsp;        return UNKNOWN;</b>
&nbsp;      }
&nbsp;
&nbsp;      @Override
&nbsp;      protected Substrings literal(String literal) {
<b class="fc">&nbsp;        return new Substrings(true, true, new String[]{literal});</b>
&nbsp;      }
&nbsp;    };
&nbsp;    try {
<b class="fc">&nbsp;      Substrings result = parser.disjunction();</b>
<b class="fc">&nbsp;      return result.substrings.length == 0 ? null : result;</b>
&nbsp;    } catch (TooComplexRegexp e) {
<b class="fc">&nbsp;      return null;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * @return all strings that the given regexp can ever match, or {@code null} if such set couldn&#39;t be enumerated
&nbsp;   */
&nbsp;  @Nullable
&nbsp;  @VisibleForTesting
&nbsp;  static Set&lt;String&gt; getPossibleRegexpValues(String regexp) {
<b class="fc">&nbsp;    RegexpParser&lt;Stream&lt;String&gt;&gt; parser = new RegexpParser&lt;Stream&lt;String&gt;&gt;(regexp) {</b>
&nbsp;      @Override
&nbsp;      Stream&lt;String&gt; handleConcatenation(Stream&lt;String&gt; left, Stream&lt;String&gt; right) {
<b class="fc">&nbsp;        List&lt;String&gt; groupResults = right.collect(Collectors.toList());</b>
<b class="fc">&nbsp;        return left.flatMap(s1 -&gt; groupResults.stream().map(s2 -&gt; s1 + s2));</b>
&nbsp;      }
&nbsp;
&nbsp;      @Override
&nbsp;      Stream&lt;String&gt; handleOr(List&lt;Stream&lt;String&gt;&gt; components) {
<b class="fc">&nbsp;        return components.stream().flatMap(Function.identity());</b>
&nbsp;      }
&nbsp;
&nbsp;      @Override
&nbsp;      protected Stream&lt;String&gt; optional(Stream&lt;String&gt; groupResults, char op) {
<b class="fc">&nbsp;        return op == &#39;?&#39; ? Stream.concat(Stream.of(&quot;&quot;), groupResults) : unknown();</b>
&nbsp;      }
&nbsp;
&nbsp;      @Override
&nbsp;      protected Stream&lt;String&gt; unknown() {
<b class="fc">&nbsp;        throw TooComplexRegexp.INSTANCE;</b>
&nbsp;      }
&nbsp;
&nbsp;      @Override
&nbsp;      protected Stream&lt;String&gt; literal(String literal) {
<b class="fc">&nbsp;        return Stream.of(literal);</b>
&nbsp;      }
&nbsp;    };
&nbsp;    try {
<b class="fc">&nbsp;      return parser.disjunction().collect(Collectors.toSet());</b>
&nbsp;    } catch (TooComplexRegexp e) {
<b class="fc">&nbsp;      return null;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private static abstract class RegexpParser&lt;T&gt; {
&nbsp;    private static final String unsupported = &quot;?$^{}*+&quot;;
&nbsp;    private static final String finishing = &quot;)|&quot;;
&nbsp;    private static final String starting = &quot;([\\&quot;;
&nbsp;    private static final String nonLiteral = finishing + unsupported + starting + &quot;.&quot;;
&nbsp;
&nbsp;    private final String regexp;
&nbsp;    private int pos;
&nbsp;
<b class="fc">&nbsp;    RegexpParser(String regexp) {</b>
<b class="fc">&nbsp;      if (regexp.startsWith(&quot;\\b&quot;)) {</b>
<b class="fc">&nbsp;        regexp = regexp.substring(2);</b>
&nbsp;      }
<b class="fc">&nbsp;      if (regexp.startsWith(&quot;^&quot;)) {</b>
<b class="fc">&nbsp;        regexp = regexp.substring(1);</b>
&nbsp;      }
<b class="pc">&nbsp;      if (regexp.endsWith(&quot;\\b&quot;) &amp;&amp; !regexp.endsWith(&quot;\\\\b&quot;)) {</b>
<b class="fc">&nbsp;        regexp = regexp.substring(0, regexp.length() - 2);</b>
&nbsp;      }
<b class="fc">&nbsp;      if (regexp.endsWith(&quot;$&quot;) &amp;&amp; !regexp.endsWith(&quot;\\$&quot;)) {</b>
<b class="fc">&nbsp;        regexp = regexp.substring(0, regexp.length() - 1);</b>
&nbsp;      }
<b class="fc">&nbsp;      this.regexp = regexp;</b>
&nbsp;    }
&nbsp;
&nbsp;    T disjunction() {
<b class="fc">&nbsp;      List&lt;T&gt; components = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;      components.add(concatenation());</b>
&nbsp;      while (true) {
<b class="fc">&nbsp;        if (pos &gt;= regexp.length() || regexp.charAt(pos) != &#39;|&#39;) {</b>
<b class="fc">&nbsp;          return components.size() == 1 ? components.get(0) : handleOr(components);</b>
&nbsp;        }
<b class="fc">&nbsp;        pos++;</b>
<b class="fc">&nbsp;        components.add(concatenation());</b>
&nbsp;      }
&nbsp;    }
&nbsp;
&nbsp;    abstract T handleOr(List&lt;T&gt; components);
&nbsp;
&nbsp;    abstract T handleConcatenation(T left, T right);
&nbsp;
&nbsp;    protected abstract T optional(T groupResults, char op);
&nbsp;
&nbsp;    protected abstract T literal(String literal);
&nbsp;
&nbsp;    protected abstract T unknown();
&nbsp;
&nbsp;    private T concatenation() {
<b class="fc">&nbsp;      T result = postfix();</b>
&nbsp;
<b class="fc">&nbsp;      while (pos &lt; regexp.length()) {</b>
<b class="fc">&nbsp;        char c = regexp.charAt(pos);</b>
<b class="fc">&nbsp;        if (finishing.indexOf(c) &gt;= 0) break;</b>
<b class="fc">&nbsp;        if (unsupported.indexOf(c) &gt;= 0) throw TooComplexRegexp.INSTANCE;</b>
&nbsp;
<b class="fc">&nbsp;        result = handleConcatenation(result, postfix());</b>
&nbsp;      }
<b class="fc">&nbsp;      return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    private T postfix() {
<b class="fc">&nbsp;      T groupResults = atom();</b>
<b class="fc">&nbsp;      if (pos &lt; regexp.length()) {</b>
<b class="fc">&nbsp;        char next = regexp.charAt(pos);</b>
<b class="fc">&nbsp;        if (next == &#39;{&#39;) {</b>
<b class="fc">&nbsp;          int closing = regexp.indexOf(&#39;}&#39;, pos + 1);</b>
<b class="pc">&nbsp;          if (closing &lt; 0) throw new AssertionError(&quot;Closing } expected after &quot; + pos);</b>
<b class="fc">&nbsp;          pos = closing + 1;</b>
<b class="fc">&nbsp;          groupResults = unknown();</b>
<b class="fc">&nbsp;          if (pos &gt;= regexp.length()) {</b>
<b class="fc">&nbsp;            return groupResults;</b>
&nbsp;          }
<b class="fc">&nbsp;          next = regexp.charAt(pos);</b>
&nbsp;        }
<b class="fc">&nbsp;        if (&quot;*+?&quot;.indexOf(next) &gt;= 0) {</b>
<b class="fc">&nbsp;          pos++;</b>
<b class="fc">&nbsp;          return optional(groupResults, next);</b>
&nbsp;        }
&nbsp;      }
<b class="fc">&nbsp;      return groupResults;</b>
&nbsp;    }
&nbsp;
&nbsp;    private T atom() {
<b class="fc">&nbsp;      if (pos &gt;= regexp.length()) return literal(&quot;&quot;);</b>
&nbsp;      
<b class="fc">&nbsp;      switch (regexp.charAt(pos)) {</b>
&nbsp;        case &#39;(&#39;:
<b class="fc">&nbsp;          if (regexp.charAt(++pos) == &#39;?&#39;) {</b>
<b class="fc">&nbsp;            if (regexp.charAt(++pos) != &#39;:&#39;) {</b>
<b class="fc">&nbsp;              throw TooComplexRegexp.INSTANCE;</b>
&nbsp;            }
<b class="fc">&nbsp;            pos++;</b>
&nbsp;          }
<b class="fc">&nbsp;          T group = disjunction();</b>
<b class="pc">&nbsp;          if (regexp.charAt(pos++) != &#39;)&#39;) throw TooComplexRegexp.INSTANCE;</b>
<b class="fc">&nbsp;          return group;</b>
&nbsp;        case &#39;[&#39;:
<b class="fc">&nbsp;          return squareBracketGroup();</b>
&nbsp;        case &#39;\\&#39;:
<b class="fc">&nbsp;          pos++;</b>
<b class="fc">&nbsp;          return charLiteral(escape());</b>
&nbsp;        case &#39;.&#39;:
<b class="fc">&nbsp;          pos++;</b>
<b class="fc">&nbsp;          return unknown();</b>
&nbsp;        default:
<b class="fc">&nbsp;          int literalStart = pos;</b>
<b class="fc">&nbsp;          while (pos &lt; regexp.length() &amp;&amp; nonLiteral.indexOf(regexp.charAt(pos)) &lt; 0) pos++;</b>
<b class="fc">&nbsp;          if (literalStart + 1 &lt; pos &amp;&amp; pos &lt; regexp.length() &amp;&amp; regexp.charAt(pos) == &#39;?&#39;) pos--;</b>
<b class="fc">&nbsp;          return literal(regexp.substring(literalStart, pos));</b>
&nbsp;      }
&nbsp;    }
&nbsp;
&nbsp;    private T squareBracketGroup() {
<b class="fc">&nbsp;      int start = ++pos;</b>
<b class="fc">&nbsp;      List&lt;Character&gt; options = new ArrayList&lt;&gt;();</b>
&nbsp;      while (true) {
<b class="fc">&nbsp;        char c1 = regexp.charAt(pos++);</b>
<b class="fc">&nbsp;        if (c1 == &#39;]&#39;) break;</b>
&nbsp;
<b class="fc">&nbsp;        if (c1 == &#39;-&#39; &amp;&amp; pos != start + 1 &amp;&amp; regexp.charAt(pos) != &#39;]&#39;) {</b>
<b class="fc">&nbsp;          Character last = options == null ? null : options.get(options.size() - 1);</b>
<b class="fc">&nbsp;          char next = regexp.charAt(pos++);</b>
<b class="pc">&nbsp;          if (last == null || next == &#39;\\&#39; || next - last &gt; 10) {</b>
<b class="fc">&nbsp;            options = null;</b>
&nbsp;          }
<b class="fc">&nbsp;          if (options != null) {</b>
<b class="fc">&nbsp;            for (int c = last + 1; c &lt;= next; c++) {</b>
<b class="fc">&nbsp;              options.add((char) c);</b>
&nbsp;            }
&nbsp;          }
<b class="fc">&nbsp;        } else if (c1 == &#39;^&#39;) {</b>
<b class="fc">&nbsp;          options = null;</b>
<b class="fc">&nbsp;        } else if (c1 == &#39;[&#39;) {</b>
<b class="fc">&nbsp;          throw TooComplexRegexp.INSTANCE;</b>
&nbsp;        } else {
<b class="fc">&nbsp;          Character simpleChar = c1 == &#39;\\&#39; ? escape() : (Character) c1;</b>
<b class="fc">&nbsp;          if (options != null) {</b>
<b class="fc">&nbsp;            options.add(simpleChar);</b>
&nbsp;          }
&nbsp;        }
&nbsp;      }
<b class="fc">&nbsp;      if (options == null) return unknown();</b>
<b class="fc">&nbsp;      List&lt;T&gt; components = options.stream().map(c -&gt; charLiteral(c)).collect(Collectors.toList());</b>
<b class="pc">&nbsp;      if (components.isEmpty()) throw TooComplexRegexp.INSTANCE;</b>
<b class="fc">&nbsp;      return components.size() == 1 ? components.get(0) : handleOr(components);</b>
&nbsp;    }
&nbsp;
&nbsp;    private T charLiteral(@Nullable Character c) {
<b class="fc">&nbsp;      return c == null ? unknown() : literal(String.valueOf(c));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Nullable
&nbsp;    private Character escape() {
<b class="fc">&nbsp;      char next = regexp.charAt(pos++);</b>
<b class="fc">&nbsp;      if (&quot;0xucpP&quot;.indexOf(next) &gt;= 0) throw TooComplexRegexp.INSTANCE;</b>
<b class="fc">&nbsp;      if (Character.isLetterOrDigit(next)) return null;</b>
<b class="fc">&nbsp;      return next;</b>
&nbsp;    }
&nbsp;
&nbsp;  }
&nbsp;
&nbsp;  private static class TooComplexRegexp extends RuntimeException {
<b class="fc">&nbsp;    private static final TooComplexRegexp INSTANCE = new TooComplexRegexp() {</b>
&nbsp;      @Override
&nbsp;      public synchronized Throwable fillInStackTrace() {
<b class="fc">&nbsp;        return this;</b>
&nbsp;      }
&nbsp;    };
&nbsp;  }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-02-17 23:50</div>
</div>
</body>
</html>
