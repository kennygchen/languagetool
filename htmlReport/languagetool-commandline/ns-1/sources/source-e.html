


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > JLanguageTool</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.languagetool</a>
</div>

<h1>Coverage Summary for Class: JLanguageTool (org.languagetool)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">JLanguageTool</td>
<td class="coverageStat">
  <span class="percent">
    64.4%
  </span>
  <span class="absValue">
    (67/104)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    44.9%
  </span>
  <span class="absValue">
    (149/332)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    61.1%
  </span>
  <span class="absValue">
    (403/660)
  </span>
</td>
</tr>
  <tr>
    <td class="name">JLanguageTool$CheckCancelledCallback</td>
  </tr>
  <tr>
    <td class="name">JLanguageTool$CleanToken</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JLanguageTool$Level</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (11/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JLanguageTool$Mode</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JLanguageTool$ParagraphHandling</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JLanguageTool$SentenceData</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JLanguageTool$TextCheckCallable</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    51.6%
  </span>
  <span class="absValue">
    (32/62)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    77.7%
  </span>
  <span class="absValue">
    (94/121)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JLanguageTool$TextCheckCallable$LineColumnPosition</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    68.1%
  </span>
  <span class="absValue">
    (81/119)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    45.9%
  </span>
  <span class="absValue">
    (181/394)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    64.7%
  </span>
  <span class="absValue">
    (526/813)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/* LanguageTool, a natural language style checker
&nbsp; * Copyright (C) 2005 Daniel Naber (http://www.danielnaber.de)
&nbsp; *
&nbsp; * This library is free software; you can redistribute it and/or
&nbsp; * modify it under the terms of the GNU Lesser General Public
&nbsp; * License as published by the Free Software Foundation; either
&nbsp; * version 2.1 of the License, or (at your option) any later version.
&nbsp; *
&nbsp; * This library is distributed in the hope that it will be useful,
&nbsp; * but WITHOUT ANY WARRANTY; without even the implied warranty of
&nbsp; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
&nbsp; * Lesser General Public License for more details.
&nbsp; *
&nbsp; * You should have received a copy of the GNU Lesser General Public
&nbsp; * License along with this library; if not, write to the Free Software
&nbsp; * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
&nbsp; * USA
&nbsp; */
&nbsp;package org.languagetool;
&nbsp;
&nbsp;import io.github.resilience4j.circuitbreaker.CircuitBreaker;
&nbsp;import io.opentelemetry.api.common.Attributes;
&nbsp;import org.apache.commons.lang3.StringUtils;
&nbsp;import org.jetbrains.annotations.NotNull;
&nbsp;import org.jetbrains.annotations.Nullable;
&nbsp;import org.languagetool.broker.ClassBroker;
&nbsp;import org.languagetool.broker.DefaultClassBroker;
&nbsp;import org.languagetool.broker.DefaultResourceDataBroker;
&nbsp;import org.languagetool.broker.ResourceDataBroker;
&nbsp;import org.languagetool.languagemodel.LanguageModel;
&nbsp;import org.languagetool.markup.AnnotatedText;
&nbsp;import org.languagetool.markup.AnnotatedTextBuilder;
&nbsp;import org.languagetool.markup.TextPart;
&nbsp;import org.languagetool.rules.*;
&nbsp;import org.languagetool.rules.patterns.*;
&nbsp;import org.languagetool.rules.spelling.SpellingCheckRule;
&nbsp;import org.languagetool.tools.LoggingTools;
&nbsp;import org.languagetool.tools.LtThreadPoolFactory;
&nbsp;import org.languagetool.tools.TelemetryProvider;
&nbsp;import org.slf4j.Logger;
&nbsp;import org.slf4j.LoggerFactory;
&nbsp;import org.xml.sax.SAXException;
&nbsp;
&nbsp;import javax.xml.parsers.ParserConfigurationException;
&nbsp;import java.io.File;
&nbsp;import java.io.IOException;
&nbsp;import java.io.InputStream;
&nbsp;import java.io.PrintStream;
&nbsp;import java.util.*;
&nbsp;import java.util.concurrent.*;
&nbsp;import java.util.function.Function;
&nbsp;import java.util.regex.Matcher;
&nbsp;import java.util.regex.Pattern;
&nbsp;import java.util.stream.Collectors;
&nbsp;import java.util.stream.IntStream;
&nbsp;
&nbsp;/**
&nbsp; * The main class used for checking text against different rules:
&nbsp; * &lt;ul&gt;
&nbsp; * &lt;li&gt;built-in Java rules (for English: &lt;i&gt;a&lt;/i&gt; vs. &lt;i&gt;an&lt;/i&gt;, whitespace after commas, ...)
&nbsp; * &lt;li&gt;built-in pattern rules loaded from external XML files (usually called {@code grammar.xml})
&nbsp; * &lt;li&gt;your own implementation of the abstract {@link Rule} classes added with {@link #addRule(Rule)}
&nbsp; * &lt;/ul&gt;
&nbsp; *
&nbsp; * &lt;p&gt;You will probably want to use the sub class {@link MultiThreadedJLanguageTool} for best performance.
&nbsp; *
&nbsp; * &lt;p&gt;&lt;b&gt;Thread-safety:&lt;/b&gt; this class is not thread safe. Create one instance per thread,
&nbsp; * but create the language only once (e.g. {@code new AmericanEnglish}) and use it for all
&nbsp; * instances of JLanguageTool.&lt;/p&gt;
&nbsp; *
&nbsp; * @see MultiThreadedJLanguageTool
&nbsp; */
&nbsp;public class JLanguageTool {
&nbsp;
<b class="fc">&nbsp;  private static final Logger logger = LoggerFactory.getLogger(JLanguageTool.class);</b>
<b class="fc">&nbsp;  private static final Pattern ZERO_WIDTH_NBSP = Pattern.compile(&quot;(?&lt;=\uFEFF)|(?=\uFEFF)&quot;);</b>
&nbsp;
&nbsp;  /**
&nbsp;   * LanguageTool version as a string like {@code 2.3} or {@code 2.4-SNAPSHOT}.
&nbsp;   * @deprecated Please use LtBuildInfo.OS.getVersion() instead.
&nbsp;   */
&nbsp;  @Nullable
&nbsp;  @Deprecated
<b class="fc">&nbsp;  public static final String VERSION = LtBuildInfo.OS.getVersion();</b>
&nbsp;
&nbsp;  /**
&nbsp;   * LanguageTool build date and time like {@code 2013-10-17 16:10} or {@code null} if not run from JAR.
&nbsp;   * @deprecated Please use LtBuildInfo.OS.getBuildDate() instead.
&nbsp;   */
&nbsp;  @Nullable
&nbsp;  @Deprecated
<b class="fc">&nbsp;  public static final String BUILD_DATE = LtBuildInfo.OS.getBuildDate();</b>
&nbsp;
&nbsp;  /**
&nbsp;   * Abbreviated git id or {@code null} if not available.
&nbsp;   * @since 4.5
&nbsp;   * @deprecated Please use LtBuildInfo.OS.getShortGitId() instead.
&nbsp;   */
&nbsp;  @Nullable
&nbsp;  @Deprecated
<b class="fc">&nbsp;  public static final String GIT_SHORT_ID = LtBuildInfo.OS.getShortGitId();</b>
&nbsp;
&nbsp;  /**
&nbsp;   * The name of the file with error patterns.
&nbsp;   */
&nbsp;  public static final String PATTERN_FILE = &quot;grammar.xml&quot;;
&nbsp;  /**
&nbsp;   * The name of the file with style patterns.
&nbsp;   */
&nbsp;  public static final String STYLE_FILE = &quot;style.xml&quot;;
&nbsp;  /**
&nbsp;   * The name of the file with error patterns.
&nbsp;   */
&nbsp;  public static final String CUSTOM_PATTERN_FILE = &quot;grammar_custom.xml&quot;;
&nbsp;  /**
&nbsp;   * The name of the file with false friend information.
&nbsp;   */
&nbsp;  public static final String FALSE_FRIEND_FILE = &quot;false-friends.xml&quot;;
&nbsp;  /**
&nbsp;   * The internal tag used to mark the beginning of a sentence.
&nbsp;   */
&nbsp;  public static final String SENTENCE_START_TAGNAME = &quot;SENT_START&quot;;
&nbsp;  /**
&nbsp;   * The internal tag used to mark the end of a sentence.
&nbsp;   */
&nbsp;  public static final String SENTENCE_END_TAGNAME = &quot;SENT_END&quot;;
&nbsp;  /**
&nbsp;   * The internal tag used to mark the end of a paragraph.
&nbsp;   */
&nbsp;  public static final String PARAGRAPH_END_TAGNAME = &quot;PARA_END&quot;;
&nbsp;  /**
&nbsp;   * Name of the message bundle for translations.
&nbsp;   */
&nbsp;  public static final String MESSAGE_BUNDLE = &quot;org.languagetool.MessagesBundle&quot;;
&nbsp;  /**
&nbsp;   * Extension of dictionary files read by Spellers
&nbsp;   */
&nbsp;  public static final String DICTIONARY_FILENAME_EXTENSION = &quot;.dict&quot;;
&nbsp;
&nbsp;  private final ResultCache cache;
&nbsp;  private final UserConfig userConfig;
&nbsp;  private final GlobalConfig globalConfig;
&nbsp;  private final ShortDescriptionProvider descProvider;
&nbsp;
&nbsp;  private float maxErrorsPerWordRate;
&nbsp;
<b class="fc">&nbsp;  private static ResourceDataBroker dataBroker = new DefaultResourceDataBroker();</b>
<b class="fc">&nbsp;  private static ClassBroker classBroker = new DefaultClassBroker();</b>
&nbsp;
<b class="fc">&nbsp;  private static volatile boolean useCustomPasswordAuthenticator = true;</b>
&nbsp;
&nbsp;  private final List&lt;Rule&gt; builtinRules;
<b class="fc">&nbsp;  private final List&lt;Rule&gt; userRules = new ArrayList&lt;&gt;(); // rules added via addRule() method</b>
&nbsp;  // rules fetched via getRelevantLanguageModelCapableRules()
<b class="fc">&nbsp;  private final Set&lt;String&gt; optionalLanguageModelRules = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;  private final Set&lt;String&gt; disabledRules = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;  private final Set&lt;CategoryId&gt; disabledRuleCategories = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;  private final Set&lt;String&gt; enabledRules = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;  private final Set&lt;CategoryId&gt; enabledRuleCategories = new HashSet&lt;&gt;();</b>
&nbsp;  private final Language language;
&nbsp;  private final List&lt;Language&gt; altLanguages;
&nbsp;  private final Language motherTongue;
&nbsp;  // allow logging of input in stack traces
&nbsp;  private final boolean inputLogging;
&nbsp;
<b class="fc">&nbsp;  private final List&lt;RuleMatchFilter&gt; matchFilters = new LinkedList&lt;&gt;();</b>
&nbsp;
&nbsp;  private CheckCancelledCallback checkCancelledCallback;
&nbsp;
&nbsp;  private PrintStream printStream;
&nbsp;  private boolean listUnknownWords;
<b class="fc">&nbsp;  private Set&lt;String&gt; unknownWords = new HashSet&lt;&gt;();</b>
&nbsp;  private boolean cleanOverlappingMatches;
&nbsp;
&nbsp;  /**
&nbsp;   * Constants for correct paragraph-rule handling.
&nbsp;   */
<b class="fc">&nbsp;  public enum ParagraphHandling {</b>
&nbsp;    /**
&nbsp;     * Handle normally - all kinds of rules run.
&nbsp;     */
<b class="fc">&nbsp;    NORMAL,</b>
&nbsp;    /**
&nbsp;     * Run only paragraph-level rules.
&nbsp;     */
<b class="fc">&nbsp;    ONLYPARA,</b>
&nbsp;    /**
&nbsp;     * Run only sentence-level rules.
&nbsp;     */
<b class="fc">&nbsp;    ONLYNONPARA</b>
&nbsp;  }
&nbsp;
<b class="fc">&nbsp;  public enum Mode {</b>
&nbsp;    // IMPORTANT: directly logged via toString into check_log database table.
&nbsp;    // column is varchar(32), so take care to not exceed this length here
&nbsp;    /**
&nbsp;     * Use all active rules for checking.
&nbsp;     */
<b class="fc">&nbsp;    ALL,</b>
&nbsp;    /**
&nbsp;     * Use only text-level rules for checking. This is typically much faster then using all rules or {@code ALL_BUT_TEXTLEVEL_ONLY}.
&nbsp;     */
<b class="fc">&nbsp;    TEXTLEVEL_ONLY,</b>
&nbsp;    /**
&nbsp;     * Use all activate rules for checking except the text-level rules.
&nbsp;     */
<b class="fc">&nbsp;    ALL_BUT_TEXTLEVEL_ONLY</b>
&nbsp;  }
&nbsp;
<b class="fc">&nbsp;  public enum Level {</b>
<b class="fc">&nbsp;    DEFAULT,</b>
<b class="fc">&nbsp;    PICKY,</b>
<b class="fc">&nbsp;    ACADEMIC,</b>
<b class="fc">&nbsp;    CLARITY,</b>
<b class="fc">&nbsp;    PROFESSIONAL,</b>
<b class="fc">&nbsp;    CREATIVE,</b>
<b class="fc">&nbsp;    CUSTOMER,</b>
<b class="fc">&nbsp;    JOBAPP,</b>
<b class="fc">&nbsp;    OBJECTIVE,</b>
<b class="fc">&nbsp;    ELEGANT</b>
&nbsp;  }
&nbsp;
<b class="fc">&nbsp;  private static final List&lt;File&gt; temporaryFiles = new ArrayList&lt;&gt;();</b>
&nbsp;
&nbsp;  /**
&nbsp;   * Create a JLanguageTool and setup the built-in rules for the
&nbsp;   * given language and false friend rules for the text language / mother tongue pair.
&nbsp;   *
&nbsp;   * @param lang         the language of the text to be checked
&nbsp;   * @param motherTongue the user&#39;s mother tongue, used for false friend rules, or &lt;code&gt;null&lt;/code&gt;.
&nbsp;   *                     The mother tongue may also be used as a source language for checking bilingual texts.
&nbsp;   */
&nbsp;  public JLanguageTool(Language lang, Language motherTongue) {
<b class="nc">&nbsp;    this(lang, motherTongue, null);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Create a JLanguageTool and setup the built-in Java rules for the
&nbsp;   * given language.
&nbsp;   *
&nbsp;   * @param language the language of the text to be checked
&nbsp;   */
&nbsp;  public JLanguageTool(Language language) {
<b class="fc">&nbsp;    this(language, null, null, null);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Create a JLanguageTool and setup the built-in rules for the
&nbsp;   * given language and false friend rules for the text language / mother tongue pair.
&nbsp;   *
&nbsp;   * @param language     the language of the text to be checked
&nbsp;   * @param motherTongue the user&#39;s mother tongue, used for false friend rules, or &lt;code&gt;null&lt;/code&gt;.
&nbsp;   *                     The mother tongue may also be used as a source language for checking bilingual texts.
&nbsp;   * @param cache        a cache to speed up checking if the same sentences get checked more than once,
&nbsp;   *                     e.g. when LT is running as a server and texts are re-checked due to changes
&nbsp;   * @since 3.7
&nbsp;   */
&nbsp;  public JLanguageTool(Language language, Language motherTongue, ResultCache cache) {
<b class="nc">&nbsp;    this(language, motherTongue, cache, null);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Create a JLanguageTool and setup the built-in rules for the
&nbsp;   * given language and false friend rules for the text language / mother tongue pair.
&nbsp;   *
&nbsp;   * @param language the language of the text to be checked
&nbsp;   * @param cache    a cache to speed up checking if the same sentences get checked more than once,
&nbsp;   *                 e.g. when LT is running as a server and texts are re-checked due to changes. Use
&nbsp;   *                 {@code null} to deactivate the cache.
&nbsp;   * @since 4.2
&nbsp;   */
&nbsp;  public JLanguageTool(Language language, ResultCache cache, UserConfig userConfig) {
<b class="nc">&nbsp;    this(language, null, cache, userConfig);</b>
&nbsp;  }
&nbsp;
&nbsp;  public JLanguageTool(Language language, List&lt;Language&gt; altLanguages, Language motherTongue, ResultCache cache,
&nbsp;                       GlobalConfig globalConfig, UserConfig userConfig) {
<b class="fc">&nbsp;    this(language, altLanguages, motherTongue, cache, globalConfig, userConfig, true);</b>
&nbsp;  }
&nbsp;  
&nbsp;  /**
&nbsp;   * Create a JLanguageTool and setup the built-in rules for the
&nbsp;   * given language and false friend rules for the text language / mother tongue pair.
&nbsp;   *
&nbsp;   * @param language     the language of the text to be checked
&nbsp;   * @param altLanguages The languages that are accepted as alternative languages - currently this means
&nbsp;   *                     words are accepted if they are in an alternative language and not similar to
&nbsp;   *                     a word from {@code language}. If there&#39;s a similar word in {@code language},
&nbsp;   *                     there will be an error of type {@link RuleMatch.Type#Hint} (EXPERIMENTAL)
&nbsp;   * @param motherTongue the user&#39;s mother tongue, used for false friend rules, or &lt;code&gt;null&lt;/code&gt;.
&nbsp;   *          The mother tongue may also be used as a source language for checking bilingual texts.
&nbsp;   * @param cache a cache to speed up checking if the same sentences get checked more than once,
&nbsp;   *              e.g. when LT is running as a server and texts are re-checked due to changes
&nbsp;   * @param inputLogging allow inclusion of input in logs on exceptions
&nbsp;   * @since 4.3
&nbsp;   */
&nbsp;  public JLanguageTool(Language language, List&lt;Language&gt; altLanguages, Language motherTongue, ResultCache cache,
<b class="fc">&nbsp;                       GlobalConfig globalConfig, UserConfig userConfig, boolean inputLogging) {</b>
<b class="fc">&nbsp;    this.language = Objects.requireNonNull(language, &quot;language cannot be null&quot;);</b>
<b class="fc">&nbsp;    this.altLanguages = Objects.requireNonNull(altLanguages, &quot;altLanguages cannot be null (but empty)&quot;);</b>
<b class="fc">&nbsp;    this.motherTongue = motherTongue;</b>
<b class="pc">&nbsp;    if (userConfig == null) {</b>
<b class="fc">&nbsp;      this.userConfig = new UserConfig();</b>
&nbsp;    } else {
<b class="nc">&nbsp;      this.userConfig = userConfig;</b>
&nbsp;    }
<b class="fc">&nbsp;    this.globalConfig = globalConfig;</b>
<b class="fc">&nbsp;    ResourceBundle messages = ResourceBundleTools.getMessageBundle(language);</b>
<b class="fc">&nbsp;    builtinRules = getAllBuiltinRules(language, messages, userConfig, globalConfig);</b>
<b class="fc">&nbsp;    this.cleanOverlappingMatches = true;</b>
&nbsp;    try {
<b class="fc">&nbsp;      activateDefaultPatternRules();</b>
<b class="pc">&nbsp;      if (!language.hasNGramFalseFriendRule(motherTongue)) {</b>
&nbsp;        // use the old false friends, which always match, not depending on context
<b class="fc">&nbsp;        activateDefaultFalseFriendRules();</b>
&nbsp;      }
<b class="fc">&nbsp;      updateOptionalLanguageModelRules(null); // start out with rules without language model</b>
&nbsp;    } catch (Exception e) {
<b class="nc">&nbsp;      throw new RuntimeException(&quot;Could not activate rules&quot;, e);</b>
&nbsp;    }
<b class="fc">&nbsp;    this.cache = cache;</b>
<b class="fc">&nbsp;    descProvider = new ShortDescriptionProvider();</b>
<b class="fc">&nbsp;    this.inputLogging = inputLogging;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Create a JLanguageTool and setup the built-in rules for the
&nbsp;   * given language and false friend rules for the text language / mother tongue pair.
&nbsp;   *
&nbsp;   * @param language     the language of the text to be checked
&nbsp;   * @param motherTongue the user&#39;s mother tongue, used for false friend rules, or &lt;code&gt;null&lt;/code&gt;.
&nbsp;   *                     The mother tongue may also be used as a source language for checking bilingual texts.
&nbsp;   * @param cache        a cache to speed up checking if the same sentences get checked more than once,
&nbsp;   *                     e.g. when LT is running as a server and texts are re-checked due to changes
&nbsp;   * @since 4.2
&nbsp;   */
&nbsp;  public JLanguageTool(Language language, Language motherTongue, ResultCache cache, UserConfig userConfig) {
<b class="fc">&nbsp;    this(language, Collections.emptyList(), motherTongue, cache, null, userConfig);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * The grammar checker needs resources from following
&nbsp;   * directories:
&nbsp;   * &lt;ul&gt;
&nbsp;   *   &lt;li&gt;{@code /resource}&lt;/li&gt;
&nbsp;   *   &lt;li&gt;{@code /rules}&lt;/li&gt;
&nbsp;   * &lt;/ul&gt;
&nbsp;   *
&nbsp;   * @return The currently set data broker which allows obtaining
&nbsp;   * resources from the mentioned directories above. If no
&nbsp;   * data broker was set, a new {@link DefaultResourceDataBroker} will
&nbsp;   * be instantiated and returned.
&nbsp;   * @since 1.0.1
&nbsp;   */
&nbsp;  public static synchronized ResourceDataBroker getDataBroker() {
<b class="fc">&nbsp;    if (JLanguageTool.dataBroker == null) {</b>
<b class="fc">&nbsp;      JLanguageTool.dataBroker = new DefaultResourceDataBroker();</b>
&nbsp;    }
<b class="fc">&nbsp;    return JLanguageTool.dataBroker;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * The grammar checker needs resources from following
&nbsp;   * directories:
&nbsp;   * &lt;ul&gt;
&nbsp;   * &lt;li&gt;{@code /resource}&lt;/li&gt;
&nbsp;   * &lt;li&gt;{@code /rules}&lt;/li&gt;
&nbsp;   * &lt;/ul&gt;
&nbsp;   *
&nbsp;   * @param broker The new resource broker to be used.
&nbsp;   * @since 1.0.1
&nbsp;   */
&nbsp;  public static synchronized void setDataBroker(ResourceDataBroker broker) {
<b class="nc">&nbsp;    JLanguageTool.dataBroker = broker;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * @return The currently set class broker which allows to load classes.
&nbsp;   * If no class broker was set, a new {@link DefaultClassBroker} will
&nbsp;   * be instantiated and returned.
&nbsp;   * @since 4.9
&nbsp;   */
&nbsp;  public static synchronized ClassBroker getClassBroker() {
<b class="pc">&nbsp;    if (JLanguageTool.classBroker == null) {</b>
<b class="nc">&nbsp;      JLanguageTool.classBroker = new DefaultClassBroker();</b>
&nbsp;    }
<b class="fc">&nbsp;    return JLanguageTool.classBroker;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * @param broker The new class broker to be used.
&nbsp;   * @since 4.9
&nbsp;   */
&nbsp;  public static synchronized void setClassBrokerBroker(ClassBroker broker) {
<b class="nc">&nbsp;    JLanguageTool.classBroker = broker;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Whether the {@code Tools.setPasswordAuthenticator()} should be called when loading rules
&nbsp;   * in rule loader to use {@code PasswordAuthenticator} as default one.
&nbsp;   *
&nbsp;   * @return true if {@code PasswordAuthenticator} should be used
&nbsp;   * @since 5.6
&nbsp;   */
&nbsp;  public static boolean isCustomPasswordAuthenticatorUsed() {
<b class="fc">&nbsp;    return JLanguageTool.useCustomPasswordAuthenticator;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Whether the {@code Tools.setPasswordAuthenticator()} should be called when loading rules
&nbsp;   * in rule loader to use {@code PasswordAuthenticator} as default one.
&nbsp;   *
&nbsp;   * @param use true if {@code PasswordAuthenticator} should be used
&nbsp;   * @since 5.6
&nbsp;   */
&nbsp;  public static void useCustomPasswordAuthenticator(boolean use) {
<b class="nc">&nbsp;    JLanguageTool.useCustomPasswordAuthenticator = use;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Whether the {@link #check(String)} methods store unknown words. If set to
&nbsp;   * &lt;code&gt;true&lt;/code&gt; (default: false), you can get the list of unknown words
&nbsp;   * using {@link #getUnknownWords()}.
&nbsp;   */
&nbsp;  public void setListUnknownWords(boolean listUnknownWords) {
<b class="fc">&nbsp;    this.listUnknownWords = listUnknownWords;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Whether the {@link #check(String)} methods return overlapping errors. If set to
&nbsp;   * &lt;code&gt;true&lt;/code&gt; (default: true), it removes overlapping errors according to
&nbsp;   * the priorities established for the language.
&nbsp;   *
&nbsp;   * @since 3.6
&nbsp;   */
&nbsp;  public void setCleanOverlappingMatches(boolean cleanOverlappingMatches) {
<b class="fc">&nbsp;    this.cleanOverlappingMatches = cleanOverlappingMatches;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Maximum errors per word rate, checking will stop with an exception if the rate is higher.
&nbsp;   * For example, with a rate of 0.33, the checking would stop if the user&#39;s
&nbsp;   * text has so many errors that more than every 3rd word causes a rule match.
&nbsp;   * Note that this may not apply for very short texts.
&nbsp;   *
&nbsp;   * @since 4.0
&nbsp;   */
&nbsp;  public void setMaxErrorsPerWordRate(float maxErrorsPerWordRate) {
<b class="nc">&nbsp;    this.maxErrorsPerWordRate = maxErrorsPerWordRate;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Callback to determine if result of executing {@link #check(String)} is still needed.
&nbsp;   */
&nbsp;  public void setCheckCancelledCallback(CheckCancelledCallback callback) {
<b class="nc">&nbsp;    this.checkCancelledCallback = callback;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Gets the ResourceBundle (i18n strings) for the default language of the user&#39;s system.
&nbsp;   */
&nbsp;  public static ResourceBundle getMessageBundle() {
<b class="nc">&nbsp;    return ResourceBundleTools.getMessageBundle();</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Gets the ResourceBundle (i18n strings) for the given user interface language.
&nbsp;   *
&nbsp;   * @since 2.4 (public since 2.4)
&nbsp;   */
&nbsp;  public static ResourceBundle getMessageBundle(Language lang) {
<b class="fc">&nbsp;    return ResourceBundleTools.getMessageBundle(lang);</b>
&nbsp;  }
&nbsp;
&nbsp;  private List&lt;Rule&gt; getAllBuiltinRules(Language language, ResourceBundle messages, UserConfig userConfig, GlobalConfig globalConfig) {
&nbsp;    try {
<b class="fc">&nbsp;      List&lt;Rule&gt; rules = new ArrayList&lt;&gt;(language.getRelevantRules(messages, userConfig, motherTongue, altLanguages));</b>
<b class="fc">&nbsp;      rules.addAll(language.getRelevantRulesGlobalConfig(messages, globalConfig, userConfig, motherTongue, altLanguages));</b>
<b class="fc">&nbsp;      return rules;</b>
&nbsp;    } catch (IOException e) {
<b class="nc">&nbsp;      throw new RuntimeException(&quot;Could not get rules of language &quot; + language, e);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Set a PrintStream that will receive verbose output. Set to
&nbsp;   * {@code null} (which is the default) to disable verbose output.
&nbsp;   */
&nbsp;  public void setOutput(PrintStream printStream) {
<b class="fc">&nbsp;    this.printStream = printStream;</b>
<b class="pc">&nbsp;    GlobalConfig.setVerbose(printStream != null);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Load pattern rules from an XML file. Use {@link #addRule(Rule)} to add these
&nbsp;   * rules to the checking process.
&nbsp;   *
&nbsp;   * @param filename path to an XML file in the classpath or in the filesystem - the classpath is checked first
&nbsp;   * @return a List of {@link PatternRule} objects
&nbsp;   */
&nbsp;  public List&lt;AbstractPatternRule&gt; loadPatternRules(String filename) throws IOException {
<b class="nc">&nbsp;    PatternRuleLoader ruleLoader = new PatternRuleLoader();</b>
<b class="nc">&nbsp;    try (InputStream is = getDataBroker().getAsStream(filename)) {</b>
<b class="nc">&nbsp;      if (is == null) {</b>
&nbsp;        // happens for external rules plugged in as an XML file or testing files:
<b class="nc">&nbsp;        if (filename.contains(&quot;-test-&quot;)) {</b>
&nbsp;          // ignore, for testing
<b class="nc">&nbsp;          return Collections.emptyList();</b>
&nbsp;        } else {
<b class="nc">&nbsp;          return ruleLoader.getRules(new File(filename), language);</b>
&nbsp;        }
&nbsp;      } else {
<b class="nc">&nbsp;        return ruleLoader.getRules(is, filename, language);</b>
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Load false friend rules from an XML file. Only those pairs will be loaded
&nbsp;   * that match the current text language and the mother tongue specified in the
&nbsp;   * JLanguageTool constructor. Use {@link #addRule(Rule)} to add these rules to the
&nbsp;   * checking process.
&nbsp;   *
&nbsp;   * @param filename path to an XML file in the classpath or in the filesystem - the classpath is checked first
&nbsp;   * @return a List of {@link PatternRule} objects, or an empty list if mother tongue is not set
&nbsp;   */
&nbsp;  public List&lt;AbstractPatternRule&gt; loadFalseFriendRules(String filename)
&nbsp;    throws ParserConfigurationException, SAXException, IOException {
<b class="fc">&nbsp;    if (motherTongue == null) {</b>
<b class="fc">&nbsp;      return Collections.emptyList();</b>
&nbsp;    }
<b class="fc">&nbsp;    FalseFriendRuleLoader ruleLoader = new FalseFriendRuleLoader(motherTongue);</b>
<b class="fc">&nbsp;    try (InputStream is = getDataBroker().getAsStream(filename)) {</b>
<b class="pc">&nbsp;      if (is == null) {</b>
<b class="nc">&nbsp;        return ruleLoader.getRules(new File(filename), language, motherTongue);</b>
&nbsp;      } else {
<b class="fc">&nbsp;        return ruleLoader.getRules(is, language, motherTongue);</b>
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Remove rules that can profit from a language model, recreate them with the given model and add them again
&nbsp;   *
&nbsp;   * @param lm the language model or null if none is available
&nbsp;   */
&nbsp;  private void updateOptionalLanguageModelRules(@Nullable LanguageModel lm) {
<b class="fc">&nbsp;    ResourceBundle messages = getMessageBundle(language);</b>
&nbsp;    try {
<b class="fc">&nbsp;      List&lt;Rule&gt; rules = language.getRelevantLanguageModelCapableRules(messages, lm, globalConfig, userConfig, motherTongue, altLanguages);</b>
<b class="fc">&nbsp;      userRules.removeIf(rule -&gt; optionalLanguageModelRules.contains(rule.getId()));</b>
<b class="fc">&nbsp;      optionalLanguageModelRules.clear();</b>
<b class="fc">&nbsp;      rules.stream().map(Rule::getId).forEach(optionalLanguageModelRules::add);</b>
<b class="fc">&nbsp;      userRules.addAll(rules);</b>
&nbsp;    } catch (Exception e) {
<b class="nc">&nbsp;      throw new RuntimeException(&quot;Could not load language model capable rules.&quot;, e);</b>
&nbsp;    }
<b class="fc">&nbsp;    ruleSetCache.clear();</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Activate rules that depend on a language model. The language model currently
&nbsp;   * consists of Lucene indexes with ngram occurrence counts.
&nbsp;   *
&nbsp;   * @param indexDir directory with a &#39;3grams&#39; sub directory which contains a Lucene index with 3gram occurrence counts
&nbsp;   * @since 2.7
&nbsp;   */
&nbsp;  public void activateLanguageModelRules(File indexDir) throws IOException {
<b class="nc">&nbsp;    LanguageModel languageModel = language.getLanguageModel(indexDir);</b>
<b class="nc">&nbsp;    if (languageModel != null) {</b>
<b class="nc">&nbsp;      ResourceBundle messages = getMessageBundle(language);</b>
<b class="nc">&nbsp;      List&lt;Rule&gt; rules = language.getRelevantLanguageModelRules(messages, languageModel, userConfig);</b>
<b class="nc">&nbsp;      userRules.addAll(rules);</b>
<b class="nc">&nbsp;      updateOptionalLanguageModelRules(languageModel);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private void transformRules(Function&lt;Rule, Rule&gt; mapper, List&lt;Rule&gt; rules) {
&nbsp;    // transform this way because variables are final + could log where rule was changed
<b class="fc">&nbsp;    for (int i = 0; i &lt; rules.size(); i++) {</b>
<b class="fc">&nbsp;      Rule original = rules.get(i);</b>
<b class="fc">&nbsp;      Rule transformed = mapper.apply(original);</b>
<b class="pc">&nbsp;      if (transformed != original) {</b>
<b class="nc">&nbsp;        rules.set(i, transformed);</b>
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  public void activateRemoteRules(@Nullable File configFile) throws IOException {
&nbsp;    List&lt;RemoteRuleConfig&gt; configs;
&nbsp;    try {
<b class="pc">&nbsp;      if (configFile != null) {</b>
<b class="nc">&nbsp;        configs = RemoteRuleConfig.load(configFile);</b>
&nbsp;      } else {
<b class="fc">&nbsp;        configs = Collections.emptyList();</b>
&nbsp;      }
<b class="fc">&nbsp;      activateRemoteRules(configs);</b>
&nbsp;    } catch (IOException e) {
<b class="nc">&nbsp;      throw new IOException(&quot;Could not load remote rules.&quot;, e);</b>
&nbsp;    } catch (ExecutionException e) {
<b class="nc">&nbsp;      throw new IOException(&quot;Could not load remote rules configuration at &quot; + configFile.getAbsolutePath(), e);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  public void activateRemoteRules(List&lt;RemoteRuleConfig&gt; configs) throws IOException {
<b class="fc">&nbsp;    List&lt;RemoteRuleConfig&gt; remoteRuleConfigs = new ArrayList&lt;&gt;(configs);</b>
<b class="pc">&nbsp;    if (!userConfig.isTrustedSource()) {</b>
<b class="fc">&nbsp;      remoteRuleConfigs = configs.stream().filter(remoteRuleConfig -&gt; !remoteRuleConfig.getOptions().getOrDefault(&quot;onlyTrustedSources&quot;, &quot;false&quot;).equals(&quot;true&quot;)).collect(Collectors.toList());</b>
&nbsp;    }
<b class="fc">&nbsp;    List&lt;Rule&gt; rules = language.getRelevantRemoteRules(getMessageBundle(language), remoteRuleConfigs,</b>
&nbsp;      globalConfig, userConfig, motherTongue, altLanguages, inputLogging);
<b class="fc">&nbsp;    userRules.addAll(rules);</b>
<b class="fc">&nbsp;    Function&lt;Rule, Rule&gt; enhanced = language.getRemoteEnhancedRules(getMessageBundle(language), remoteRuleConfigs, userConfig, motherTongue, altLanguages, inputLogging);</b>
<b class="fc">&nbsp;    transformRules(enhanced, builtinRules);</b>
<b class="fc">&nbsp;    transformRules(enhanced, userRules);</b>
<b class="fc">&nbsp;    ruleSetCache.clear();</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Loads and activates the pattern rules from
&nbsp;   * {@code org/languagetool/rules/&lt;languageCode&gt;/grammar.xml}.
&nbsp;   */
&nbsp;  private void activateDefaultPatternRules() throws IOException {
<b class="fc">&nbsp;    List&lt;AbstractPatternRule&gt; patternRules = language.getPatternRules();</b>
<b class="fc">&nbsp;    List&lt;String&gt; enabledRules = language.getDefaultEnabledRulesForVariant();</b>
<b class="fc">&nbsp;    List&lt;String&gt; disabledRules = language.getDefaultDisabledRulesForVariant();</b>
<b class="pc">&nbsp;    if (!enabledRules.isEmpty() || !disabledRules.isEmpty()) {</b>
<b class="fc">&nbsp;      for (AbstractPatternRule patternRule : patternRules) {</b>
<b class="fc">&nbsp;        if (enabledRules.contains(patternRule.getId())) {</b>
<b class="fc">&nbsp;          patternRule.setDefaultOn();</b>
&nbsp;        }
<b class="fc">&nbsp;        if (disabledRules.contains(patternRule.getId())) {</b>
<b class="fc">&nbsp;          patternRule.setDefaultOff();</b>
&nbsp;        }
&nbsp;      }
&nbsp;    }
<b class="fc">&nbsp;    List&lt;Rule&gt; transformed = transformPatternRules(patternRules, language);</b>
<b class="fc">&nbsp;    userRules.addAll(transformed);</b>
&nbsp;  }
&nbsp;
&nbsp;  private List&lt;Rule&gt; transformPatternRules(List&lt;AbstractPatternRule&gt; patternRules, Language lang) {
<b class="fc">&nbsp;    List&lt;AbstractPatternRule&gt; rules = new ArrayList&lt;&gt;(patternRules);</b>
<b class="fc">&nbsp;    List&lt;PatternRuleTransformer&gt; transforms = Arrays.asList(new RepeatedPatternRuleTransformer(lang),</b>
&nbsp;      new ConsistencyPatternRuleTransformer(lang));
<b class="fc">&nbsp;    List&lt;Rule&gt; transformed = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;    for (PatternRuleTransformer op : transforms) {</b>
<b class="fc">&nbsp;      PatternRuleTransformer.TransformedRules result = op.apply(rules);</b>
<b class="fc">&nbsp;      rules = result.getRemainingRules();</b>
<b class="fc">&nbsp;      transformed.addAll(result.getTransformedRules());</b>
&nbsp;    }
<b class="fc">&nbsp;    transformed.addAll(rules);</b>
<b class="fc">&nbsp;    return transformed;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Loads and activates the false friend rules from
&nbsp;   * &lt;code&gt;rules/false-friends.xml&lt;/code&gt;.
&nbsp;   */
&nbsp;  private void activateDefaultFalseFriendRules()
&nbsp;    throws ParserConfigurationException, SAXException, IOException {
<b class="fc">&nbsp;    String falseFriendRulesFilename = JLanguageTool.getDataBroker().getRulesDir() + &quot;/&quot; + FALSE_FRIEND_FILE;</b>
<b class="fc">&nbsp;    userRules.addAll(loadFalseFriendRules(falseFriendRulesFilename));</b>
<b class="fc">&nbsp;    ruleSetCache.clear();</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Add a {@link RuleMatchFilter} for post-processing of rule matches
&nbsp;   * Filters are called sequentially in the same order as added
&nbsp;   *
&nbsp;   * @param filter filter to add
&nbsp;   * @since 4.7
&nbsp;   */
&nbsp;  public void addMatchFilter(@NotNull RuleMatchFilter filter) {
<b class="nc">&nbsp;    matchFilters.add(Objects.requireNonNull(filter));</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Add a rule to be used by the next call to the check methods like {@link #check(String)}.
&nbsp;   */
&nbsp;  public void addRule(Rule rule) {
<b class="fc">&nbsp;    userRules.add(rule);</b>
<b class="fc">&nbsp;    ruleSetCache.clear();</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Disable a given rule so the check methods like {@link #check(String)} won&#39;t use it.
&nbsp;   *
&nbsp;   * @param ruleId the id of the rule to disable - no error will be thrown if the id does not exist
&nbsp;   * @see #enableRule(String)
&nbsp;   */
&nbsp;  public void disableRule(String ruleId) {
<b class="fc">&nbsp;    disabledRules.add(ruleId);</b>
<b class="fc">&nbsp;    enabledRules.remove(ruleId);</b>
<b class="fc">&nbsp;    ruleSetCache.clear();</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Disable the given rules so the check methods like {@link #check(String)} won&#39;t use them.
&nbsp;   *
&nbsp;   * @param ruleIds the ids of the rules to disable - no error will be thrown if the id does not exist
&nbsp;   * @since 2.4
&nbsp;   */
&nbsp;  public void disableRules(List&lt;String&gt; ruleIds) {
<b class="nc">&nbsp;    disabledRules.addAll(ruleIds);</b>
<b class="nc">&nbsp;    enabledRules.removeAll(ruleIds);</b>
<b class="nc">&nbsp;    ruleSetCache.clear();</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Disable the given rule category so the check methods like {@link #check(String)} won&#39;t use it.
&nbsp;   *
&nbsp;   * @param id the id of the category to disable - no error will be thrown if the id does not exist
&nbsp;   * @see #enableRuleCategory(CategoryId)
&nbsp;   * @since 3.3
&nbsp;   */
&nbsp;  public void disableCategory(CategoryId id) {
<b class="nc">&nbsp;    disabledRuleCategories.add(id);</b>
<b class="nc">&nbsp;    enabledRuleCategories.remove(id);</b>
<b class="nc">&nbsp;    ruleSetCache.clear();</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Returns true if a category is explicitly disabled.
&nbsp;   *
&nbsp;   * @param id the id of the category to check - no error will be thrown if the id does not exist
&nbsp;   * @return true if this category is explicitly disabled.
&nbsp;   * @see #disableCategory(CategoryId)
&nbsp;   * @since 3.5
&nbsp;   */
&nbsp;  public boolean isCategoryDisabled(CategoryId id) {
<b class="nc">&nbsp;    return disabledRuleCategories.contains(id);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Get the language that was used to configure this instance.
&nbsp;   */
&nbsp;  public Language getLanguage() {
<b class="fc">&nbsp;    return language;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Get rule ids of the rules that have been explicitly disabled.
&nbsp;   */
&nbsp;  public Set&lt;String&gt; getDisabledRules() {
<b class="nc">&nbsp;    return disabledRules;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Enable a given rule so the check methods like {@link #check(String)} will use it.
&nbsp;   * This will &lt;em&gt;not&lt;/em&gt; throw an exception if the given rule id doesn&#39;t exist.
&nbsp;   *
&nbsp;   * @param ruleId the id of the rule to enable
&nbsp;   * @see #disableRule(String)
&nbsp;   */
&nbsp;  public void enableRule(String ruleId) {
<b class="fc">&nbsp;    disabledRules.remove(ruleId);</b>
<b class="fc">&nbsp;    enabledRules.add(ruleId);</b>
<b class="fc">&nbsp;    ruleSetCache.clear();</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Enable all rules of the given category so the check methods like {@link #check(String)} will use it.
&nbsp;   * This will &lt;em&gt;not&lt;/em&gt; throw an exception if the given rule id doesn&#39;t exist.
&nbsp;   *
&nbsp;   * @see #disableCategory(CategoryId)
&nbsp;   * @since 3.3
&nbsp;   */
&nbsp;  public void enableRuleCategory(CategoryId id) {
<b class="nc">&nbsp;    disabledRuleCategories.remove(id);</b>
<b class="nc">&nbsp;    enabledRuleCategories.add(id);</b>
<b class="nc">&nbsp;    ruleSetCache.clear();</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Tokenizes the given text into sentences.
&nbsp;   */
&nbsp;  public List&lt;String&gt; sentenceTokenize(String text) {
<b class="fc">&nbsp;    return language.getSentenceTokenizer().tokenize(text);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * The main check method. Tokenizes the text into sentences and matches these
&nbsp;   * sentences against all currently active rules.
&nbsp;   *
&nbsp;   * @param text the text to be checked
&nbsp;   * @return a List of {@link RuleMatch} objects
&nbsp;   */
&nbsp;  public List&lt;RuleMatch&gt; check(String text) throws IOException {
<b class="fc">&nbsp;    return check(text, true, ParagraphHandling.NORMAL);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * The main check method. Tokenizes the text into sentences and matches these
&nbsp;   * sentences against all currently active rules.
&nbsp;   *
&nbsp;   * @param text the text to be checked
&nbsp;   * @param level the level to use for text checking, e.g. whether picky rules should be activated
&nbsp;   * @return a List of {@link RuleMatch} objects
&nbsp;   */
&nbsp;  public List&lt;RuleMatch&gt; check(String text, Level level) throws IOException {
<b class="nc">&nbsp;    return check(new AnnotatedTextBuilder().addText(text).build(), true, ParagraphHandling.NORMAL, null, level);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * The main check method. Tokenizes the text into sentences and matches these
&nbsp;   * sentences against all currently active rules.
&nbsp;   *
&nbsp;   * @param text the text to be checked
&nbsp;   * @return a List of {@link RuleMatch} objects
&nbsp;   * @since 3.7
&nbsp;   */
&nbsp;  public List&lt;RuleMatch&gt; check(String text, RuleMatchListener listener) throws IOException {
<b class="nc">&nbsp;    return check(text, true, ParagraphHandling.NORMAL, listener);</b>
&nbsp;  }
&nbsp;
&nbsp;  public List&lt;RuleMatch&gt; check(String text, boolean tokenizeText, ParagraphHandling paraMode) throws IOException {
<b class="fc">&nbsp;    return check(new AnnotatedTextBuilder().addText(text).build(), tokenizeText, paraMode);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * @since 3.7
&nbsp;   */
&nbsp;  public List&lt;RuleMatch&gt; check(String text, boolean tokenizeText, ParagraphHandling paraMode, RuleMatchListener listener) throws IOException {
<b class="nc">&nbsp;    return check(new AnnotatedTextBuilder().addText(text).build(), tokenizeText, paraMode, listener);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * The main check method. Tokenizes the text into sentences and matches these
&nbsp;   * sentences against all currently active rules, adjusting error positions so they refer
&nbsp;   * to the original text &lt;em&gt;including&lt;/em&gt; markup.
&nbsp;   *
&nbsp;   * @since 2.3
&nbsp;   */
&nbsp;  public List&lt;RuleMatch&gt; check(AnnotatedText text) throws IOException {
<b class="nc">&nbsp;    return check(text, true, ParagraphHandling.NORMAL);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * @since 3.9
&nbsp;   */
&nbsp;  public List&lt;RuleMatch&gt; check(AnnotatedText text, RuleMatchListener listener) throws IOException {
<b class="nc">&nbsp;    return check(text, true, ParagraphHandling.NORMAL, listener);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * The main check method. Tokenizes the text into sentences and matches these
&nbsp;   * sentences against all currently active rules.
&nbsp;   *
&nbsp;   * @param annotatedText The text to be checked, created with {@link AnnotatedTextBuilder}.
&nbsp;   *                      Call this method with the complete text to be checked. If you call it
&nbsp;   *                      repeatedly with smaller chunks like paragraphs or sentence, those rules that work across
&nbsp;   *                      paragraphs/sentences won&#39;t work (their status gets reset whenever this method is called).
&nbsp;   * @param tokenizeText  If true, then the text is tokenized into sentences.
&nbsp;   *                      Otherwise, it is assumed it&#39;s already tokenized, i.e. it is only one sentence
&nbsp;   * @param paraMode      Uses paragraph-level rules only if true.
&nbsp;   * @return a List of {@link RuleMatch} objects, describing potential errors in the text
&nbsp;   * @since 2.3
&nbsp;   */
&nbsp;  public List&lt;RuleMatch&gt; check(AnnotatedText annotatedText, boolean tokenizeText, ParagraphHandling paraMode) throws IOException {
<b class="fc">&nbsp;    return check(annotatedText, tokenizeText, paraMode, null);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * The main check method. Tokenizes the text into sentences and matches these
&nbsp;   * sentences against all currently active rules.
&nbsp;   */
&nbsp;  public List&lt;RuleMatch&gt; check(AnnotatedText annotatedText, boolean tokenizeText, ParagraphHandling paraMode, RuleMatchListener listener) throws IOException {
<b class="fc">&nbsp;    return check(annotatedText, tokenizeText, paraMode, listener, Level.DEFAULT);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * The main check method. Tokenizes the text into sentences and matches these
&nbsp;   * sentences against all currently active rules.
&nbsp;   *
&nbsp;   * @since 3.7
&nbsp;   */
&nbsp;  public List&lt;RuleMatch&gt; check(AnnotatedText annotatedText, boolean tokenizeText, ParagraphHandling paraMode, RuleMatchListener listener, Level level) throws IOException {
&nbsp;    Mode mode;
<b class="pc">&nbsp;    if (paraMode == ParagraphHandling.ONLYNONPARA) {</b>
<b class="nc">&nbsp;      mode = Mode.ALL_BUT_TEXTLEVEL_ONLY;</b>
<b class="pc">&nbsp;    } else if (paraMode == ParagraphHandling.ONLYPARA) {</b>
<b class="nc">&nbsp;      mode = Mode.TEXTLEVEL_ONLY;</b>
&nbsp;    } else {
<b class="fc">&nbsp;      mode = Mode.ALL;</b>
&nbsp;    }
<b class="fc">&nbsp;    return check(annotatedText, tokenizeText, paraMode, listener, mode, level);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * The main check method. Tokenizes the text into sentences and matches these
&nbsp;   * sentences against all currently active rules depending on {@code mode}.
&nbsp;   *
&nbsp;   * @since 4.3
&nbsp;   */
&nbsp;  public List&lt;RuleMatch&gt; check(AnnotatedText annotatedText, boolean tokenizeText, ParagraphHandling paraMode, RuleMatchListener listener, Mode mode, Level level) throws IOException {
<b class="fc">&nbsp;    return check(annotatedText, tokenizeText, paraMode, listener, mode, level, null);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * The main check method. Tokenizes the text into sentences and matches these
&nbsp;   * sentences against all currently active rules depending on {@code mode}.
&nbsp;   *
&nbsp;   * @param textSessionID UserConfig.getTextSessionID can be outdated because of pipeline pool caching, so pass through directly
&nbsp;   * @since 5.2
&nbsp;   */
&nbsp;  public List&lt;RuleMatch&gt; check(AnnotatedText annotatedText, boolean tokenizeText, ParagraphHandling paraMode, RuleMatchListener listener,
&nbsp;                               Mode mode, Level level, @Nullable Long textSessionID) throws IOException {
<b class="fc">&nbsp;    annotatedText = cleanText(annotatedText);</b>
<b class="fc">&nbsp;    List&lt;String&gt; sentences = getSentences(annotatedText, tokenizeText);</b>
<b class="fc">&nbsp;    List&lt;AnalyzedSentence&gt; analyzedSentences = analyzeSentences(sentences);</b>
<b class="fc">&nbsp;    return checkInternal(annotatedText, paraMode, listener, mode, level, textSessionID, sentences, analyzedSentences).getRuleMatches();</b>
&nbsp;  }
&nbsp;
&nbsp;  public CheckResults check2(AnnotatedText annotatedText, boolean tokenizeText, ParagraphHandling paraMode, RuleMatchListener listener,
&nbsp;                             Mode mode, Level level, @Nullable Long textSessionID)throws IOException {
<b class="nc">&nbsp;    return check2(annotatedText, tokenizeText, paraMode, listener, mode, level, Collections.emptySet(), textSessionID); </b>
&nbsp;  }
&nbsp;  
&nbsp;  public CheckResults check2(AnnotatedText annotatedText, boolean tokenizeText, ParagraphHandling paraMode, RuleMatchListener listener,
&nbsp;                             Mode mode, Level level, @NotNull Set&lt;ToneTag&gt; toneTags, @Nullable Long textSessionID) throws IOException {
<b class="nc">&nbsp;    annotatedText = cleanText(annotatedText);</b>
<b class="nc">&nbsp;    List&lt;String&gt; sentences = getSentences(annotatedText, tokenizeText);</b>
<b class="nc">&nbsp;    List&lt;AnalyzedSentence&gt; analyzedSentences = analyzeSentences(sentences);</b>
<b class="nc">&nbsp;    CheckResults checkResults = checkInternal(annotatedText, paraMode, listener, mode, level, toneTags, textSessionID, sentences, analyzedSentences);</b>
<b class="nc">&nbsp;    List&lt;SentenceRange&gt; sentenceRanges = SentenceRange.getRangesFromSentences(annotatedText, sentences);</b>
<b class="nc">&nbsp;    checkResults.addSentenceRanges(sentenceRanges);</b>
<b class="nc">&nbsp;    return checkResults;</b>
&nbsp;  }
&nbsp;
&nbsp;  private List&lt;String&gt; getSentences(AnnotatedText annotatedText, boolean tokenizeText) {
&nbsp;    List&lt;String&gt; sentences;
<b class="pc">&nbsp;    if (tokenizeText) {</b>
<b class="fc">&nbsp;      sentences = sentenceTokenize(annotatedText.getPlainText());</b>
&nbsp;    } else {
<b class="nc">&nbsp;      sentences = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;      sentences.add(annotatedText.getPlainText());</b>
&nbsp;    }
<b class="fc">&nbsp;    return sentences;</b>
&nbsp;  }
&nbsp;
&nbsp;  private AnnotatedText cleanText(AnnotatedText annotatedText) {
<b class="fc">&nbsp;    AnnotatedTextBuilder atb = new AnnotatedTextBuilder();</b>
<b class="fc">&nbsp;    annotatedText.getGlobalMetaData().forEach(atb::addGlobalMetaData);</b>
<b class="fc">&nbsp;    annotatedText.getCustomMetaData().forEach(atb::addGlobalMetaData);</b>
<b class="fc">&nbsp;    List&lt;TextPart&gt; parts = annotatedText.getParts();</b>
<b class="fc">&nbsp;    for (TextPart part : parts) {</b>
<b class="pc">&nbsp;      if (part.getType() == TextPart.Type.TEXT) {</b>
<b class="fc">&nbsp;        String byteOrderMark = &quot;\uFEFF&quot;;  // BOM or zero-width non-breaking space</b>
&nbsp;        // split by byteOrderMark and let the delimiter also be part of the array
<b class="fc">&nbsp;        String[] split = ZERO_WIDTH_NBSP.split(part.getPart());</b>
<b class="fc">&nbsp;        for (String text : split) {</b>
<b class="pc">&nbsp;          if (&quot;\uFEFF&quot;.equals(text)) {</b>
<b class="nc">&nbsp;            atb.addMarkup(byteOrderMark);</b>
&nbsp;          } else {
<b class="fc">&nbsp;            atb.addText(text);</b>
&nbsp;          }
&nbsp;        }
&nbsp;      } else {
<b class="nc">&nbsp;        atb.add(part);</b>
&nbsp;      }
&nbsp;    }
<b class="fc">&nbsp;    return atb.build();</b>
&nbsp;  }
&nbsp;
&nbsp;  protected CheckResults checkInternal(AnnotatedText annotatedText, ParagraphHandling paraMode, RuleMatchListener listener,
&nbsp;                                     Mode mode, Level level,
&nbsp;                                     @Nullable Long textSessionID, List&lt;String&gt; sentences, List&lt;AnalyzedSentence&gt; analyzedSentences) throws IOException {
<b class="fc">&nbsp;    return checkInternal(annotatedText, paraMode, listener, mode, level, Collections.emptySet(), textSessionID, sentences, analyzedSentences);</b>
&nbsp;  }
&nbsp;
&nbsp;  protected CheckResults checkInternal(AnnotatedText annotatedText, ParagraphHandling paraMode, RuleMatchListener listener,
&nbsp;                                     Mode mode, Level level, @NotNull Set&lt;ToneTag&gt; toneTags,
&nbsp;                                     @Nullable Long textSessionID, List&lt;String&gt; sentences, List&lt;AnalyzedSentence&gt; analyzedSentences) throws IOException {
<b class="fc">&nbsp;    RuleSet rules = getActiveRulesForLevelAndToneTags(level, toneTags);</b>
<b class="fc">&nbsp;    if (printStream != null) {</b>
<b class="fc">&nbsp;      printIfVerbose(rules.allRules().size() + &quot; rules activated for language &quot; + language);</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    List&lt;RuleMatch&gt; remoteMatches = new LinkedList&lt;&gt;();</b>
&nbsp;    List&lt;FutureTask&lt;RemoteRuleResult&gt;&gt; remoteRuleTasks;
&nbsp;
&nbsp;    // tone tag and level filtering can not be applied to these rules before processing
<b class="fc">&nbsp;    List&lt;RemoteRule&gt; remoteRules = rules.allRules().stream()</b>
<b class="fc">&nbsp;      .filter(RemoteRule.class::isInstance).map(RemoteRule.class::cast)</b>
<b class="fc">&nbsp;      .collect(Collectors.toList());</b>
&nbsp;
<b class="fc">&nbsp;    long remoteRuleCheckStart = System.nanoTime();</b>
&nbsp;    // map by sentence index, as the same sentence can be repeated multiple times in a text
&nbsp;    // -&gt; need to distinguish offsets / matches
<b class="fc">&nbsp;    Map&lt;Integer, List&lt;RuleMatch&gt;&gt; cachedResults = new HashMap&lt;&gt;();</b>
<b class="fc">&nbsp;    Map&lt;Integer, Integer&gt; matchOffset = new HashMap&lt;&gt;();</b>
&nbsp;    // store actual request sizes (i.e. without cached sentences), so timeouts and metrics are calculated correctly
<b class="fc">&nbsp;    List&lt;Integer&gt; requestSize = new ArrayList&lt;&gt;();</b>
&nbsp;    ExecutorService remoteRulesThreadPool =
<b class="pc">&nbsp;      mode == Mode.TEXTLEVEL_ONLY || remoteRules.isEmpty() ? null :</b>
<b class="fc">&nbsp;      LtThreadPoolFactory.getFixedThreadPoolExecutor(LtThreadPoolFactory.REMOTE_RULE_EXECUTING_POOL).orElse(null);</b>
<b class="pc">&nbsp;    if (remoteRulesThreadPool != null) {</b>
&nbsp;      // trigger remote rules to run on whole text at once, at the start, then we wait for the results
<b class="nc">&nbsp;      remoteRuleTasks = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;      checkRemoteRules(remoteRules, analyzedSentences, mode, level,</b>
&nbsp;        remoteRuleTasks, requestSize, cachedResults, matchOffset, textSessionID, remoteRulesThreadPool, toneTags);
&nbsp;    } else {
<b class="fc">&nbsp;      remoteRuleTasks = null;</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    long deadlineStartNanos = System.nanoTime();</b>
<b class="pc">&nbsp;    CheckResults res = performCheck(analyzedSentences, sentences, rules,</b>
&nbsp;            paraMode, annotatedText, listener, mode, level, remoteRulesThreadPool == null, toneTags);
<b class="fc">&nbsp;    long textCheckEnd = System.nanoTime();</b>
&nbsp;
<b class="fc">&nbsp;    Map&lt;String, RemoteRuleResult&gt; remoteRulesResults = null;</b>
&nbsp;    try {
<b class="fc">&nbsp;      remoteRulesResults = TelemetryProvider.INSTANCE.createSpan(&quot;fetch-remote-rules&quot;,</b>
<b class="fc">&nbsp;        Attributes.builder().put(&quot;check.remote_rules.count&quot;, remoteRules.size()).build(),</b>
<b class="fc">&nbsp;        () -&gt; fetchRemoteRuleResults(deadlineStartNanos, mode, level, analyzedSentences, remoteMatches, remoteRuleTasks, remoteRules, requestSize,</b>
&nbsp;          cachedResults, matchOffset, annotatedText, textSessionID, toneTags));
&nbsp;    } catch (Exception e) {
<b class="nc">&nbsp;      throw new RuntimeException(e);</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    long remoteRuleCheckEnd = System.nanoTime();</b>
<b class="pc">&nbsp;    if (remoteRules.size() &gt; 0) {</b>
<b class="nc">&nbsp;      long wait = TimeUnit.NANOSECONDS.toMillis(remoteRuleCheckEnd - textCheckEnd);</b>
<b class="nc">&nbsp;      logger.info(&quot;Local checks took {}ms, remote checks {}ms; waited {}ms on remote results&quot;,</b>
<b class="nc">&nbsp;        TimeUnit.NANOSECONDS.toMillis(textCheckEnd - deadlineStartNanos),</b>
<b class="nc">&nbsp;        TimeUnit.NANOSECONDS.toMillis(remoteRuleCheckEnd - remoteRuleCheckStart), wait);</b>
<b class="nc">&nbsp;      RemoteRuleMetrics.wait(language.getShortCode(), wait);</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    List&lt;RuleMatch&gt; ruleMatches = res.getRuleMatches();</b>
&nbsp;
<b class="fc">&nbsp;    ruleMatches.addAll(remoteMatches);</b>
&nbsp;
<b class="fc">&nbsp;    if (ruleMatches.isEmpty()) {</b>
<b class="fc">&nbsp;      return res;</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    ruleMatches = filterMatches(annotatedText, rules, ruleMatches, level, toneTags, remoteRulesResults);</b>
&nbsp;
&nbsp;    // decide if this should be done right after performCheck, before waiting for remote rule results
&nbsp;    // better for latency, remote rules probably don&#39;t need resorting
&nbsp;    // complications with application of other filters?
<b class="fc">&nbsp;    List&lt;GRPCPostProcessing&gt; postProcessingRules = GRPCPostProcessing.get(language);</b>
<b class="fc">&nbsp;    List&lt;RuleMatch&gt; finalRuleMatches = ruleMatches;</b>
&nbsp;    try {
<b class="fc">&nbsp;      ruleMatches = TelemetryProvider.INSTANCE.createSpan(&quot;grpc-postprocessing&quot;, Attributes.builder().put(&quot;check.post_processing.rule_count&quot;, postProcessingRules.size()).build(), () -&gt; {</b>
<b class="fc">&nbsp;        List&lt;RuleMatch&gt; localMatches = finalRuleMatches;</b>
<b class="pc">&nbsp;        for (GRPCPostProcessing postProcessing : postProcessingRules) {</b>
<b class="nc">&nbsp;          localMatches = postProcessing.filter(analyzedSentences, localMatches, textSessionID, inputLogging);</b>
&nbsp;        }
<b class="fc">&nbsp;        return localMatches;</b>
&nbsp;      });
&nbsp;    } catch (Exception e) {
<b class="nc">&nbsp;      throw new RuntimeException(e);</b>
&nbsp;    }
&nbsp;    // TODO: maybe we need another filter pass after post processing eventually or move it here
&nbsp;    // but currently post processing is not extensively used
&nbsp;
<b class="fc">&nbsp;    return new CheckResults(ruleMatches, res.getIgnoredRanges(), res.getExtendedSentenceRanges());</b>
&nbsp;  }
&nbsp;
&nbsp;  private List&lt;RuleMatch&gt; filterMatches(AnnotatedText annotatedText, RuleSet rules, List&lt;RuleMatch&gt; ruleMatches, Level level,
&nbsp;                                        Set&lt;ToneTag&gt; toneTags, Map&lt;String, RemoteRuleResult&gt; remoteRulesResults) {
&nbsp;    // rules can create matches with rule IDs different from the original rule (see e.g. RemoteRules)
&nbsp;    // so while we can&#39;t avoid execution of these rules, we still want disabling them to work
&nbsp;    // so do another pass with ignoreRule here
<b class="fc">&nbsp;    ruleMatches = ruleMatches.stream().filter(match -&gt; !ignoreRule(match.getRule())).collect(Collectors.toList());</b>
&nbsp;
<b class="fc">&nbsp;    ruleMatches = ruleMatches.stream().filter(match -&gt; isRuleActiveForLanguageWithModel(</b>
<b class="fc">&nbsp;      match.getRule(), language, remoteRulesResults)).collect(Collectors.toList());</b>
&nbsp;
<b class="fc">&nbsp;    ruleMatches = ruleMatches.stream().filter(match -&gt; isRuleActiveForLevelAndToneTags(</b>
<b class="fc">&nbsp;      match.getRule(), level, toneTags)).collect(Collectors.toList());</b>
&nbsp;
<b class="fc">&nbsp;    ruleMatches = new SameRuleGroupFilter().filter(ruleMatches);</b>
&nbsp;    // no sorting: SameRuleGroupFilter sorts rule matches already
<b class="fc">&nbsp;    ruleMatches = new LanguageDependentRuleMatchFilter(language, rules).filter(ruleMatches, annotatedText);</b>
<b class="fc">&nbsp;    if (cleanOverlappingMatches) {</b>
<b class="fc">&nbsp;      ruleMatches = new CleanOverlappingFilter(language, userConfig.getHidePremiumMatches()).filter(ruleMatches);</b>
&nbsp;    }
<b class="fc">&nbsp;    return applyCustomFilters(ruleMatches, annotatedText);</b>
&nbsp;  }
&nbsp;
&nbsp;  private boolean isRuleActiveForLanguageWithModel(Rule rule, Language language, Map&lt;String, RemoteRuleResult&gt; remoteRulesResults) {
<b class="pc">&nbsp;    if (language.getShortCode().equals(&quot;fr&quot;)) {</b>
<b class="nc">&nbsp;      List&lt;String&gt; disableFrenchRuleGroups = Arrays.asList(&quot;OU&quot;, &quot;OU_FIGEES&quot;, &quot;VIRG_NON_TROUVEE&quot;, &quot;A_A_ACCENT&quot;,&quot;A_ACCENT_A&quot;, &quot;CONFUSION_A_AS&quot;, &quot;AGREEMENT_POSTPONED_ADJ&quot;, &quot;LA_OU&quot;, &quot;CONFUSION_RULE_PREMIUM_AIRE_AIR&quot;); // List for rule group IDs</b>
<b class="nc">&nbsp;      List&lt;String&gt; disableFrenchSpecificSubrules = Arrays.asList(&quot;A_A_ACCENT2[1]&quot;, &quot;ACCORD_SUJET_VERBE[55]&quot;, &quot;PAS_DE_VIRGULE[42]&quot;); // List for specific subrules</b>
<b class="nc">&nbsp;      RemoteRuleResult remoteRulesResult = remoteRulesResults.get(&quot;AI_FR_GGEC&quot;);</b>
<b class="nc">&nbsp;      if (remoteRulesResult != null &amp;&amp; remoteRulesResult.isSuccess()) {</b>
<b class="nc">&nbsp;        boolean isDisabledGroup = disableFrenchRuleGroups.contains(rule.getId());</b>
<b class="nc">&nbsp;        boolean isDisabledSubrule = disableFrenchSpecificSubrules.contains(rule.getFullId());</b>
<b class="nc">&nbsp;        return !(isDisabledGroup || isDisabledSubrule);</b>
&nbsp;      }
&nbsp;    }
<b class="pc">&nbsp;    if (language.getShortCode().equals(&quot;es&quot;)) {</b>
<b class="nc">&nbsp;      List&lt;String&gt; disableSpanishRules = Collections.singletonList(&quot;AGREEMENT_POSTPONED_ADJ&quot;);</b>
<b class="nc">&nbsp;      RemoteRuleResult remoteRulesResult = remoteRulesResults.get(&quot;AI_ES_GGEC&quot;);</b>
<b class="nc">&nbsp;      if (remoteRulesResult != null) {</b>
<b class="nc">&nbsp;        if (remoteRulesResult.isSuccess()) {</b>
<b class="nc">&nbsp;          return !disableSpanishRules.contains(rule.getId());</b>
&nbsp;        }
&nbsp;      }
&nbsp;    }
<b class="fc">&nbsp;    return true;</b>
&nbsp;  }
&nbsp;
<b class="fc">&nbsp;  private final Map&lt;LevelToneTagCacheKey, RuleSet&gt; ruleSetCache = new ConcurrentHashMap&lt;&gt;();</b>
&nbsp;
&nbsp;  static boolean isRuleActiveForLevelAndToneTags(Rule rule, Level level, Set&lt;ToneTag&gt; toneTags) {
&nbsp;
<b class="pc">&nbsp;    if (level == Level.DEFAULT &amp;&amp; rule.hasTag(Tag.picky)) {</b>
<b class="fc">&nbsp;      return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    List&lt;ToneTag&gt; enabledToneTags;
<b class="pc">&nbsp;    if (toneTags.contains(ToneTag.ALL_TONE_RULES)) {</b>
<b class="nc">&nbsp;      enabledToneTags = ToneTag.REAL_TONE_TAGS;</b>
<b class="pc">&nbsp;    } else if (toneTags.contains(ToneTag.NO_TONE_RULE)) {</b>
<b class="nc">&nbsp;      enabledToneTags = Collections.emptyList(); //Even clarity rules will be disabled.</b>
<b class="pc">&nbsp;    } else if (toneTags.isEmpty() || toneTags.contains(ToneTag.ALL_WITHOUT_GOAL_SPECIFIC)){</b>
<b class="fc">&nbsp;      enabledToneTags = Collections.singletonList(ToneTag.ALL_WITHOUT_GOAL_SPECIFIC);</b>
&nbsp;    } else {
<b class="nc">&nbsp;      enabledToneTags = new ArrayList&lt;&gt;(toneTags);</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    if (rule.getToneTags().isEmpty()) {</b>
<b class="fc">&nbsp;      return true;</b>
&nbsp;    }
<b class="pc">&nbsp;    if (enabledToneTags.contains(ToneTag.ALL_WITHOUT_GOAL_SPECIFIC)) {</b>
<b class="fc">&nbsp;      return !rule.isGoalSpecific();</b>
&nbsp;    }
<b class="nc">&nbsp;    boolean removeRule = true;</b>
<b class="nc">&nbsp;    for (ToneTag toneTag : enabledToneTags) {</b>
<b class="nc">&nbsp;      if (rule.hasToneTag(toneTag)) {</b>
<b class="nc">&nbsp;        removeRule = false;</b>
&nbsp;        break;
&nbsp;      }
&nbsp;    }
<b class="nc">&nbsp;    return !removeRule;</b>
&nbsp;  }
&nbsp;
&nbsp;  private RuleSet getActiveRulesForLevelAndToneTags(Level level, Set&lt;ToneTag&gt; toneTags) {
<b class="fc">&nbsp;    LevelToneTagCacheKey key = new LevelToneTagCacheKey(level, toneTags);</b>
<b class="fc">&nbsp;    return ruleSetCache.computeIfAbsent(key, levelToneTagCacheKey -&gt; {</b>
<b class="fc">&nbsp;      List&lt;Rule&gt; allRules = new ArrayList&lt;&gt;(getAllActiveRules());</b>
<b class="fc">&nbsp;      allRules.removeIf(rule -&gt; !isRuleActiveForLevelAndToneTags(rule, level, toneTags));</b>
<b class="fc">&nbsp;      return RuleSet.textLemmaHinted(allRules);</b>
&nbsp;    });
&nbsp;  }
&nbsp;
&nbsp;  protected Map&lt;String, RemoteRuleResult&gt; fetchRemoteRuleResults(long deadlineStartNanos, Mode mode, Level level, List&lt;AnalyzedSentence&gt; analyzedSentences, List&lt;RuleMatch&gt; remoteMatches,
&nbsp;                                        List&lt;FutureTask&lt;RemoteRuleResult&gt;&gt; remoteRuleTasks, List&lt;RemoteRule&gt; remoteRules,
&nbsp;                                        List&lt;Integer&gt; requestSize,
&nbsp;                                        Map&lt;Integer, List&lt;RuleMatch&gt;&gt; cachedResults,
&nbsp;                                        Map&lt;Integer, Integer&gt; matchOffset,
&nbsp;                                        AnnotatedText annotatedText, Long textSessionID,
&nbsp;                                        Set&lt;ToneTag&gt; toneTags) {
<b class="fc">&nbsp;    Map&lt;String, RemoteRuleResult&gt; remoteRuleResults = new HashMap&lt;&gt;();</b>
<b class="pc">&nbsp;    if (remoteRuleTasks != null &amp;&amp; !remoteRuleTasks.isEmpty()) {</b>
<b class="nc">&nbsp;      int timeout = IntStream.range(0, requestSize.size()).map(i -&gt;</b>
<b class="nc">&nbsp;        (int) remoteRules.get(i).getTimeout(requestSize.get(i))</b>
<b class="nc">&nbsp;      ).max().getAsInt();</b>
&nbsp;      long deadlineEndNanos;
<b class="nc">&nbsp;      if (timeout &lt;= 0) {</b>
<b class="nc">&nbsp;        deadlineEndNanos = 0;</b>
&nbsp;      } else {
<b class="nc">&nbsp;        deadlineEndNanos = deadlineStartNanos + TimeUnit.MILLISECONDS.toNanos(timeout);</b>
&nbsp;      }
&nbsp;      // fetch results from remote rules
<b class="nc">&nbsp;      for (int taskIndex = 0; taskIndex &lt; remoteRuleTasks.size(); taskIndex++) {</b>
<b class="nc">&nbsp;        FutureTask&lt;RemoteRuleResult&gt; task = remoteRuleTasks.get(taskIndex);</b>
<b class="nc">&nbsp;        RemoteRule rule = remoteRules.get(taskIndex);</b>
<b class="nc">&nbsp;        String ruleKey = rule.getId();</b>
<b class="nc">&nbsp;        long chars = requestSize.get(taskIndex);</b>
<b class="nc">&nbsp;        if (task == null &amp;&amp; chars == 0) { // everything cached</b>
&nbsp;          //logger.info(&quot;Results for remote rule already cached&quot;);
&nbsp;          continue;
<b class="nc">&nbsp;        } else if (task == null) { // circuitbreaker open or task rejected from pool</b>
&nbsp;          // rejected tasks are already logged/tracked in LtThreadPoolFactory
<b class="nc">&nbsp;          RemoteRuleMetrics.request(ruleKey, deadlineStartNanos, chars, RemoteRuleMetrics.RequestResult.DOWN);</b>
&nbsp;          continue;
&nbsp;        }
<b class="nc">&nbsp;        RemoteRuleResult remoteRuleResult = null;</b>
&nbsp;        try {
&nbsp;          //logger.info(&quot;Fetching results for remote rule for {} chars&quot;, chars);
<b class="nc">&nbsp;          remoteRuleResult = RemoteRuleMetrics.inCircuitBreaker(deadlineStartNanos, rule.circuitBreaker(), ruleKey, chars, () -&gt;</b>
<b class="nc">&nbsp;            fetchResults(deadlineStartNanos, mode, level, analyzedSentences, remoteMatches, matchOffset, annotatedText, textSessionID, chars, deadlineEndNanos, task, rule, ruleKey, toneTags));</b>
&nbsp;        } catch (InterruptedException e) {
&nbsp;          break;
&nbsp;        }
<b class="nc">&nbsp;        if (remoteRuleResult != null) {</b>
<b class="nc">&nbsp;          remoteRuleResults.put(ruleKey, remoteRuleResult);</b>
&nbsp;        }
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      for (Integer cachedSentenceIndex : cachedResults.keySet()) {</b>
<b class="nc">&nbsp;        List&lt;RuleMatch&gt; cachedMatches = cachedResults.get(cachedSentenceIndex);</b>
<b class="nc">&nbsp;        int sentenceOffset = matchOffset.get(cachedSentenceIndex);</b>
<b class="nc">&nbsp;        for (RuleMatch cachedMatch : cachedMatches) {</b>
&nbsp;          // clone so that we don&#39;t adjust match position for cache
<b class="nc">&nbsp;          RuleMatch match = new RuleMatch(cachedMatch);</b>
<b class="nc">&nbsp;          adjustOffset(annotatedText, sentenceOffset, match);</b>
<b class="nc">&nbsp;          remoteMatches.add(match);</b>
&nbsp;        }
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      for (RuleMatch match : remoteMatches) {</b>
<b class="nc">&nbsp;        match.setSuggestedReplacementObjects(extendSuggestions(match.getSuggestedReplacementObjects()));</b>
&nbsp;      }
&nbsp;
&nbsp;      // cancel any remaining tasks (e.g. after interrupt because request timed out)
<b class="nc">&nbsp;      remoteRuleTasks.stream().filter(Objects::nonNull).forEach(t -&gt; t.cancel(true));</b>
&nbsp;    }
<b class="fc">&nbsp;    return remoteRuleResults;</b>
&nbsp;  }
&nbsp;
&nbsp;  private RemoteRuleResult fetchResults(long deadlineStartNanos, Mode mode, Level level, List&lt;AnalyzedSentence&gt; analyzedSentences, List&lt;RuleMatch&gt; remoteMatches, Map&lt;Integer, Integer&gt; matchOffset, AnnotatedText annotatedText, Long textSessionID, long chars, long deadlineEndNanos, FutureTask&lt;RemoteRuleResult&gt; task, RemoteRule rule, String ruleKey, Set&lt;ToneTag&gt; toneTags) throws InterruptedException, ExecutionException, TimeoutException {
&nbsp;    RemoteRuleResult result;
<b class="nc">&nbsp;    if (rule.getTimeout(chars) &lt;= 0) {</b>
<b class="nc">&nbsp;      result = task.get();</b>
&nbsp;    } else {
<b class="nc">&nbsp;      long waitTime = Math.max(0, deadlineEndNanos - System.nanoTime());</b>
<b class="nc">&nbsp;      logger.debug(&quot;Waiting for {}ms for check of {} ({} chars)&quot;,</b>
<b class="nc">&nbsp;        TimeUnit.NANOSECONDS.toMillis(waitTime), ruleKey, chars);</b>
<b class="nc">&nbsp;      result = task.get(waitTime, TimeUnit.NANOSECONDS);</b>
&nbsp;    }
<b class="nc">&nbsp;    RemoteRuleMetrics.RequestResult loggedResult = result.isSuccess() ?</b>
<b class="nc">&nbsp;      RemoteRuleMetrics.RequestResult.SUCCESS : RemoteRuleMetrics.RequestResult.ERROR;</b>
<b class="nc">&nbsp;    if (result.isRemote()) {</b>
<b class="nc">&nbsp;      RemoteRuleMetrics.request(ruleKey, deadlineStartNanos, chars, loggedResult);</b>
&nbsp;    }
<b class="nc">&nbsp;    for (int sentenceIndex = 0; sentenceIndex &lt; analyzedSentences.size(); sentenceIndex++) {</b>
<b class="nc">&nbsp;      AnalyzedSentence sentence = analyzedSentences.get(sentenceIndex);</b>
<b class="nc">&nbsp;      List&lt;RuleMatch&gt; matches = result.matchesForSentence(sentence);</b>
<b class="nc">&nbsp;      if (matches == null) {</b>
&nbsp;        continue;
&nbsp;      }
<b class="nc">&nbsp;      if (cache != null &amp;&amp; result.isSuccess()) {</b>
&nbsp;        // store in cache
<b class="nc">&nbsp;        InputSentence cacheKey = new InputSentence(</b>
<b class="nc">&nbsp;          sentence.getText(), language, motherTongue, disabledRules, disabledRuleCategories,</b>
&nbsp;          enabledRules, enabledRuleCategories, userConfig, altLanguages, mode, level, textSessionID, toneTags);
<b class="nc">&nbsp;        Map&lt;String, List&lt;RuleMatch&gt;&gt; cacheEntry = cache.getRemoteMatchesCache().get(cacheKey, HashMap::new);</b>
<b class="nc">&nbsp;        cacheEntry.put(ruleKey, matches);</b>
&nbsp;      }
&nbsp;      // adjust rule match position
&nbsp;      // rules check all sentences batched, but should keep position adjustment logic out of rule
<b class="nc">&nbsp;      int offset = matchOffset.get(sentenceIndex);</b>
&nbsp;      // clone matches before adjusting offsets
&nbsp;      // match objects could be relevant to multiple (duplicate) sentences at different offsets
<b class="nc">&nbsp;      List&lt;RuleMatch&gt; adjustedMatches = matches.stream().map(RuleMatch::new).collect(Collectors.toList());</b>
<b class="nc">&nbsp;      for (RuleMatch match : adjustedMatches) {</b>
<b class="nc">&nbsp;        adjustOffset(annotatedText, offset, match);</b>
&nbsp;      }
<b class="nc">&nbsp;      remoteMatches.addAll(adjustedMatches);</b>
&nbsp;    }
<b class="nc">&nbsp;    return result;</b>
&nbsp;  }
&nbsp;
&nbsp;  private void adjustOffset(AnnotatedText annotatedText, int offset, RuleMatch match) {
&nbsp;    int fromPos;
&nbsp;    int toPos;
<b class="nc">&nbsp;    if (annotatedText != null) {</b>
<b class="nc">&nbsp;      fromPos = annotatedText.getOriginalTextPositionFor(match.getFromPos() + offset, false);</b>
<b class="nc">&nbsp;      toPos = annotatedText.getOriginalTextPositionFor(match.getToPos() + offset - 1, true) + 1;</b>
&nbsp;    } else {
<b class="nc">&nbsp;      fromPos = match.getFromPos() + offset;</b>
<b class="nc">&nbsp;      toPos = match.getToPos() + offset;</b>
&nbsp;    }
<b class="nc">&nbsp;    match.setOffsetPosition(fromPos, toPos);</b>
&nbsp;  }
&nbsp;
&nbsp;  private void checkRemoteRules(List&lt;RemoteRule&gt; rules, List&lt;AnalyzedSentence&gt; analyzedSentences, Mode mode, Level level,
&nbsp;                                List&lt;FutureTask&lt;RemoteRuleResult&gt;&gt; remoteRuleTasks, List&lt;Integer&gt; requestSize,
&nbsp;                                Map&lt;Integer, List&lt;RuleMatch&gt;&gt; cachedResults, Map&lt;Integer, Integer&gt; matchOffset,
&nbsp;                                Long textSessionID, ExecutorService executor, Set&lt;ToneTag&gt; toneTags) {
<b class="nc">&nbsp;    List&lt;InputSentence&gt; cacheKeys = new LinkedList&lt;&gt;();</b>
<b class="nc">&nbsp;    int offset = 0;</b>
&nbsp;    // prepare keys for caching, offsets for adjusting match positions
<b class="nc">&nbsp;    for (int i = 0; i &lt; analyzedSentences.size(); i++) {</b>
<b class="nc">&nbsp;      AnalyzedSentence s = analyzedSentences.get(i);</b>
<b class="nc">&nbsp;      matchOffset.put(i, offset);</b>
<b class="nc">&nbsp;      offset += s.getText().length();</b>
<b class="nc">&nbsp;      InputSentence cacheKey = new InputSentence(s.getText(), language, motherTongue,</b>
&nbsp;        disabledRules, disabledRuleCategories, enabledRules, enabledRuleCategories,
&nbsp;        userConfig, altLanguages, mode, level, textSessionID, toneTags);
<b class="nc">&nbsp;      cacheKeys.add(cacheKey);</b>
&nbsp;    }
<b class="nc">&nbsp;    for (RemoteRule rule : rules) {</b>
&nbsp;      FutureTask&lt;RemoteRuleResult&gt; task;
&nbsp;      List&lt;AnalyzedSentence&gt; input;
&nbsp;      int size;
<b class="nc">&nbsp;      if (cache != null) {</b>
<b class="nc">&nbsp;        List&lt;AnalyzedSentence&gt; nonCachedSentences = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        for (int sentenceIndex = 0; sentenceIndex &lt; analyzedSentences.size(); sentenceIndex++) {</b>
&nbsp;          // filter out sentences with cached results
<b class="nc">&nbsp;          InputSentence cacheKey = cacheKeys.get(sentenceIndex);</b>
<b class="nc">&nbsp;          String ruleKey = rule.getId();</b>
<b class="nc">&nbsp;          AnalyzedSentence sentence = analyzedSentences.get(sentenceIndex);</b>
&nbsp;          Map&lt;String, List&lt;RuleMatch&gt;&gt; cacheEntry;
&nbsp;          try {
<b class="nc">&nbsp;            cacheEntry = cache.getRemoteMatchesCache().get(cacheKey, HashMap::new);</b>
&nbsp;          } catch (ExecutionException e) {
<b class="nc">&nbsp;            throw new RuntimeException(e);</b>
&nbsp;          }
<b class="nc">&nbsp;          if (cacheEntry == null) {</b>
<b class="nc">&nbsp;            throw new RuntimeException(&quot;Couldn&#39;t access remote matches cache.&quot;);</b>
&nbsp;          }
<b class="nc">&nbsp;          List&lt;RuleMatch&gt; cachedMatches = cacheEntry.get(ruleKey);</b>
&nbsp;          // mark for check or retrieve from cache
<b class="nc">&nbsp;          if (cachedMatches == null) {</b>
<b class="nc">&nbsp;            nonCachedSentences.add(sentence);</b>
&nbsp;          } else {
<b class="nc">&nbsp;            cachedResults.putIfAbsent(sentenceIndex, new LinkedList&lt;&gt;());</b>
<b class="nc">&nbsp;            cachedResults.get(sentenceIndex).addAll(cachedMatches);</b>
&nbsp;          }
&nbsp;        }
&nbsp;        // userConfig is cached by pipeline pool,
&nbsp;        // logger.info(&quot;Checking {} not cached sentences out of {}&quot;, nonCachedSentences.size(), analyzedSentences.size());
<b class="nc">&nbsp;        input = nonCachedSentences;</b>
&nbsp;      } else {
<b class="nc">&nbsp;        input = analyzedSentences;</b>
&nbsp;      }
<b class="nc">&nbsp;      size = input.stream().map(s -&gt; s.getText().length()).reduce(0, Integer::sum);</b>
<b class="nc">&nbsp;      task = rule.run(input, textSessionID);</b>
<b class="nc">&nbsp;      requestSize.add(size);</b>
&nbsp;
&nbsp;      try {
&nbsp;        // skip calls (which send requests) if open/forced_open
&nbsp;        // try calls if half_open
&nbsp;        // would need manual tracking if we use tryAcquirePermission, this is easier
&nbsp;        // does require automaticTransitionFromOpenToHalfOpenEnabled setting
<b class="nc">&nbsp;        if (size == 0 ||</b>
<b class="nc">&nbsp;          rule.circuitBreaker().getState() == CircuitBreaker.State.OPEN ||</b>
<b class="nc">&nbsp;          rule.circuitBreaker().getState() == CircuitBreaker.State.FORCED_OPEN) {</b>
<b class="nc">&nbsp;          task = null;</b>
&nbsp;        } else {
<b class="nc">&nbsp;          executor.submit(task);</b>
&nbsp;        }
<b class="nc">&nbsp;        remoteRuleTasks.add(task);</b>
&nbsp;      } catch (RejectedExecutionException ignored) {
&nbsp;        // remoteRuleTasks and remoteRules lists are expected to be aligned
<b class="nc">&nbsp;        remoteRuleTasks.add(null);</b>
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Use this method if you want to access LanguageTool&#39;s otherwise
&nbsp;   * internal analysis of the text. For actual text checking, use the {@code check...} methods instead.
&nbsp;   *
&nbsp;   * @param text The text to be analyzed
&nbsp;   * @since 2.5
&nbsp;   */
&nbsp;  public List&lt;AnalyzedSentence&gt; analyzeText(String text) throws IOException {
<b class="nc">&nbsp;    List&lt;String&gt; sentences = sentenceTokenize(text);</b>
<b class="nc">&nbsp;    return analyzeSentences(sentences);</b>
&nbsp;  }
&nbsp;
&nbsp;  protected List&lt;AnalyzedSentence&gt; analyzeSentences(List&lt;String&gt; sentences) throws IOException {
<b class="fc">&nbsp;    unknownWords = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;    List&lt;AnalyzedSentence&gt; analyzedSentences = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;    int j = 0;</b>
<b class="fc">&nbsp;    for (String sentence : sentences) {</b>
<b class="pc">&nbsp;      if (checkCancelledCallback != null &amp;&amp; checkCancelledCallback.checkCancelled()) {</b>
&nbsp;        break;
&nbsp;      }
<b class="fc">&nbsp;      AnalyzedSentence analyzedSentence = getAnalyzedSentence(sentence);</b>
<b class="fc">&nbsp;      rememberUnknownWords(analyzedSentence);</b>
<b class="pc">&nbsp;      if (++j == sentences.size()) {</b>
<b class="fc">&nbsp;        analyzedSentence = markAsParagraphEnd(analyzedSentence);</b>
&nbsp;      }
<b class="fc">&nbsp;      analyzedSentences.add(analyzedSentence);</b>
<b class="fc">&nbsp;      printSentenceInfo(analyzedSentence);</b>
&nbsp;    }
<b class="fc">&nbsp;    return analyzedSentences;</b>
&nbsp;  }
&nbsp;
&nbsp;  @NotNull
&nbsp;  static AnalyzedSentence markAsParagraphEnd(AnalyzedSentence analyzedSentence) {
<b class="fc">&nbsp;    AnalyzedTokenReadings[] anTokens = analyzedSentence.getTokens();</b>
<b class="fc">&nbsp;    anTokens[anTokens.length - 1].setParagraphEnd();</b>
<b class="fc">&nbsp;    AnalyzedTokenReadings[] preDisambigAnTokens = analyzedSentence.getPreDisambigTokens();</b>
<b class="fc">&nbsp;    preDisambigAnTokens[anTokens.length - 1].setParagraphEnd();</b>
<b class="fc">&nbsp;    return new AnalyzedSentence(anTokens, preDisambigAnTokens);  ///TODO: why???</b>
&nbsp;  }
&nbsp;
&nbsp;  protected void printSentenceInfo(AnalyzedSentence analyzedSentence) {
<b class="fc">&nbsp;    if (printStream != null) {</b>
<b class="fc">&nbsp;      printIfVerbose(analyzedSentence.toString());</b>
<b class="fc">&nbsp;      printIfVerbose(analyzedSentence.getAnnotations());</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * @since 5.2
&nbsp;   */
&nbsp;  protected CheckResults performCheck(List&lt;AnalyzedSentence&gt; analyzedSentences, List&lt;String&gt; sentenceTexts,
&nbsp;                                         RuleSet ruleSet, ParagraphHandling paraMode, AnnotatedText annotatedText, RuleMatchListener listener, Mode mode, Level level, boolean checkRemoteRules, Set&lt;ToneTag&gt; toneTags) throws IOException {
<b class="fc">&nbsp;    List&lt;SentenceData&gt; sentences = computeSentenceData(analyzedSentences, sentenceTexts);</b>
<b class="fc">&nbsp;    Callable&lt;CheckResults&gt; matcher = new TextCheckCallable(ruleSet, sentences, paraMode, annotatedText, listener, mode, level, checkRemoteRules, toneTags);</b>
&nbsp;    try {
<b class="fc">&nbsp;      return matcher.call();</b>
&nbsp;    } catch (IOException e) {
&nbsp;      throw e;
&nbsp;    } catch (Exception e) {
<b class="nc">&nbsp;      throw new RuntimeException(e);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  protected final List&lt;SentenceData&gt; computeSentenceData(List&lt;AnalyzedSentence&gt; analyzedSentences, List&lt;String&gt; texts) {
<b class="fc">&nbsp;    int charCount = 0;</b>
<b class="fc">&nbsp;    int lineCount = 0;</b>
<b class="fc">&nbsp;    int columnCount = 1;</b>
<b class="fc">&nbsp;    List&lt;SentenceData&gt; result = new ArrayList&lt;&gt;(texts.size());</b>
&nbsp;
<b class="pc">&nbsp;    if (analyzedSentences == null || analyzedSentences.isEmpty()) {</b>
<b class="nc">&nbsp;      return result;</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    for (int i = 0; i &lt; texts.size(); i++) {</b>
<b class="fc">&nbsp;      String sentence = texts.get(i);</b>
<b class="fc">&nbsp;      result.add(new SentenceData(analyzedSentences.get(i), sentence, charCount, lineCount, columnCount));</b>
&nbsp;
<b class="fc">&nbsp;      charCount += sentence.length();</b>
<b class="fc">&nbsp;      lineCount += countLineBreaks(sentence);</b>
<b class="fc">&nbsp;      columnCount = processColumnChange(columnCount, sentence);</b>
&nbsp;    }
<b class="fc">&nbsp;    return result;</b>
&nbsp;  }
&nbsp;
&nbsp;  private int processColumnChange(int columnCount, String sentence) {
<b class="fc">&nbsp;    int lineBreakPos = sentence.lastIndexOf(&#39;\n&#39;);</b>
<b class="fc">&nbsp;    if (lineBreakPos == -1) {</b>
<b class="fc">&nbsp;      columnCount += sentence.length();</b>
&nbsp;    } else {
<b class="fc">&nbsp;      columnCount = sentence.length() - lineBreakPos;</b>
<b class="pc">&nbsp;      if (lineBreakPos == 0 &amp;&amp; !language.getSentenceTokenizer().singleLineBreaksMarksPara()) {</b>
<b class="nc">&nbsp;        columnCount--;</b>
&nbsp;      }
&nbsp;    }
<b class="fc">&nbsp;    return columnCount;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * This is an internal method that&#39;s public only for technical reasons.
&nbsp;   *
&nbsp;   * @since 2.3
&nbsp;   * @deprecated use one of the {@link #check} methods instead.
&nbsp;   */
&nbsp;  @Deprecated
&nbsp;  public List&lt;RuleMatch&gt; checkAnalyzedSentence(ParagraphHandling paraMode,
&nbsp;                                               List&lt;Rule&gt; rules, AnalyzedSentence analyzedSentence) throws IOException {
<b class="nc">&nbsp;    List&lt;Rule&gt; nonIgnored = rules.stream().filter(r -&gt; !ignoreRule(r)).collect(Collectors.toList());</b>
<b class="nc">&nbsp;    return checkAnalyzedSentence(paraMode, nonIgnored, analyzedSentence, false);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * This is an internal method that&#39;s public only for technical reasons, please use one
&nbsp;   * of the {@link #check(String)} methods instead.
&nbsp;   *
&nbsp;   * @since 4.9
&nbsp;   */
&nbsp;  public List&lt;RuleMatch&gt; checkAnalyzedSentence(ParagraphHandling paraMode,
&nbsp;                                               List&lt;Rule&gt; rules, AnalyzedSentence analyzedSentence, boolean checkRemoteRules) throws IOException {
<b class="fc">&nbsp;    return checkAnalyzedSentence(paraMode, rules, analyzedSentence, checkRemoteRules, -1);</b>
&nbsp;  }
&nbsp;
&nbsp;  private List&lt;RuleMatch&gt; checkAnalyzedSentence(ParagraphHandling paraMode, List&lt;Rule&gt; rules, AnalyzedSentence analyzedSentence, boolean checkRemoteRules, int wordCounter) throws IOException {
<b class="pc">&nbsp;    if (paraMode == ParagraphHandling.ONLYPARA) {</b>
<b class="nc">&nbsp;      return Collections.emptyList();</b>
&nbsp;    }
<b class="fc">&nbsp;    List&lt;RuleMatch&gt; sentenceMatches = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;    List&lt;String&gt; errorRateLog = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;    float tmpErrorsPerWord = 0.0f;</b>
<b class="fc">&nbsp;    for (int i = 0, rulesSize = rules.size(); i &lt; rulesSize; i++) {</b>
<b class="fc">&nbsp;      Rule rule = rules.get(i);</b>
<b class="pc">&nbsp;      if (rule instanceof TextLevelRule || !checkRemoteRules &amp;&amp; rule instanceof RemoteRule) {</b>
&nbsp;        continue;
&nbsp;      }
<b class="pc">&nbsp;      if (checkCancelledCallback != null &amp;&amp; checkCancelledCallback.checkCancelled()) {</b>
&nbsp;        break;
&nbsp;      }
<b class="fc">&nbsp;      RuleMatch[] thisMatches = rule.match(analyzedSentence);</b>
<b class="fc">&nbsp;      Collections.addAll(sentenceMatches, thisMatches);</b>
<b class="fc">&nbsp;      if (wordCounter &gt; 0) {</b>
&nbsp;        //check if the maxErrorsPerWordRate is already reached for the full text with this sentence and rule  
<b class="fc">&nbsp;        float errorsPerWord = sentenceMatches.size() / (float) wordCounter;</b>
<b class="fc">&nbsp;        if (tmpErrorsPerWord &lt; errorsPerWord) {</b>
<b class="fc">&nbsp;          errorRateLog.add(&quot;With rule: &quot; + rule.getFullId() + &quot; &quot; + (i+1) + &quot;/&quot; + rulesSize + &quot; the sentence error rate increased by: &quot; + (errorsPerWord - tmpErrorsPerWord) + &quot; from: &quot; + tmpErrorsPerWord + &quot; to total: &quot; + errorsPerWord);</b>
<b class="fc">&nbsp;          tmpErrorsPerWord = errorsPerWord;</b>
&nbsp;        }
<b class="pc">&nbsp;        if (maxErrorsPerWordRate &gt; 0 &amp;&amp; errorsPerWord &gt; maxErrorsPerWordRate &amp;&amp; wordCounter &gt; 25) {</b>
<b class="nc">&nbsp;          errorRateLog.forEach(e -&gt; logger.info(LoggingTools.BAD_REQUEST, e));</b>
<b class="nc">&nbsp;          logger.info(LoggingTools.BAD_REQUEST, &quot;ErrorRateTooHigh is reached by a single sentence after rule: &quot; + rule.getFullId() + &quot;. &quot; +</b>
&nbsp;            &quot;The whole text contains &quot; + wordCounter + &quot; words &quot; +
<b class="nc">&nbsp;            &quot; and this sentence has &quot; + sentenceMatches.size() + &quot; matches.&quot;);</b>
<b class="nc">&nbsp;          throw new ErrorRateTooHighException(&quot;ErrorRateTooHigh is reached by a single sentence after rule: &quot; + rule.getFullId() + &quot;. &quot; +</b>
&nbsp;            &quot;The whole text contains &quot; + wordCounter + &quot; words &quot; +
<b class="nc">&nbsp;            &quot;and this sentence has &quot; + sentenceMatches.size() + &quot; matches.&quot;);</b>
&nbsp;        }
&nbsp;      }
&nbsp;    }
<b class="fc">&nbsp;    if (sentenceMatches.isEmpty()) {</b>
<b class="fc">&nbsp;      return sentenceMatches;</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    AnnotatedText text = new AnnotatedTextBuilder().addText(analyzedSentence.getText()).build();</b>
&nbsp;    // rules can create matches with rule IDs different from the original rule (see e.g. RemoteRules)
&nbsp;    // so while we can&#39;t avoid execution of these rules, we still want disabling them to work
&nbsp;    // so do another pass with ignoreRule here
<b class="fc">&nbsp;    sentenceMatches = sentenceMatches.stream()</b>
<b class="fc">&nbsp;      .filter(match -&gt; !ignoreRule(match.getRule())).collect(Collectors.toList());</b>
<b class="fc">&nbsp;    return applyCustomFilters(new SameRuleGroupFilter().filter(sentenceMatches), text);</b>
&nbsp;  }
&nbsp;
&nbsp;  private boolean ignoreRule(Rule rule) {
<b class="fc">&nbsp;    Category ruleCategory = rule.getCategory();</b>
<b class="pc">&nbsp;    boolean isCategoryDisabled = (disabledRuleCategories.contains(ruleCategory.getId()) || rule.getCategory().isDefaultOff())</b>
<b class="fc">&nbsp;      &amp;&amp; !enabledRuleCategories.contains(ruleCategory.getId());</b>
<b class="fc">&nbsp;    boolean isRuleDisabled = disabledRules.contains(rule.getFullId()) || disabledRules.contains(rule.getId())</b>
<b class="fc">&nbsp;      || (rule.isDefaultOff() &amp;&amp; !(enabledRules.contains(rule.getFullId()) || enabledRules.contains(rule.getId())));</b>
&nbsp;    boolean isDisabled;
<b class="fc">&nbsp;    if (isCategoryDisabled) {</b>
<b class="pc">&nbsp;      isDisabled = !(enabledRules.contains(rule.getFullId()) || enabledRules.contains(rule.getId()));</b>
&nbsp;    } else {
<b class="fc">&nbsp;      isDisabled = isRuleDisabled;</b>
&nbsp;    }
<b class="fc">&nbsp;    return isDisabled;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Change RuleMatch positions so they are relative to the complete text,
&nbsp;   * not just to the sentence.
&nbsp;   *
&nbsp;   * @param charCount   Count of characters in the sentences before
&nbsp;   * @param columnCount Current column number
&nbsp;   * @param lineCount   Current line number
&nbsp;   * @param sentence    The text being checked
&nbsp;   * @return The RuleMatch object with adjustments
&nbsp;   */
&nbsp;  public RuleMatch adjustRuleMatchPos(RuleMatch match, int charCount,
&nbsp;                                      int columnCount, int lineCount, String sentence, AnnotatedText annotatedText) {
<b class="fc">&nbsp;    int fromPos = match.getFromPos() + charCount;</b>
<b class="fc">&nbsp;    int toPos = match.getToPos() + charCount;</b>
<b class="fc">&nbsp;    if (annotatedText != null) {</b>
<b class="fc">&nbsp;      fromPos = annotatedText.getOriginalTextPositionFor(fromPos, false);</b>
<b class="fc">&nbsp;      toPos = annotatedText.getOriginalTextPositionFor(toPos - 1, true) + 1;</b>
&nbsp;    }
<b class="fc">&nbsp;    RuleMatch thisMatch = new RuleMatch(match);</b>
<b class="fc">&nbsp;    thisMatch.setOffsetPosition(fromPos, toPos);</b>
&nbsp;    //keep the positions with respect to sentence start
<b class="fc">&nbsp;    thisMatch.setSentencePosition(match.getFromPos(), match.getToPos());</b>
&nbsp;
<b class="fc">&nbsp;    int startPos = match.getPatternFromPos() + charCount;</b>
<b class="fc">&nbsp;    int endPos = match.getPatternToPos() + charCount;</b>
<b class="fc">&nbsp;    thisMatch.setPatternPosition(startPos, endPos);</b>
&nbsp;
<b class="fc">&nbsp;    thisMatch.setLazySuggestedReplacements(() -&gt; extendSuggestions(match.getSuggestedReplacementObjects()));</b>
&nbsp;
<b class="fc">&nbsp;    String sentencePartToError = sentence.substring(0, match.getFromPos());</b>
<b class="fc">&nbsp;    String sentencePartToEndOfError = sentence.substring(0, match.getToPos());</b>
<b class="fc">&nbsp;    int lastLineBreakPos = sentencePartToError.lastIndexOf(&#39;\n&#39;);</b>
&nbsp;    int column;
&nbsp;    int endColumn;
<b class="fc">&nbsp;    if (lastLineBreakPos == -1) {</b>
<b class="fc">&nbsp;      column = sentencePartToError.length() + columnCount;</b>
&nbsp;    } else {
<b class="fc">&nbsp;      column = sentencePartToError.length() - lastLineBreakPos;</b>
&nbsp;    }
<b class="fc">&nbsp;    int lastLineBreakPosInError = sentencePartToEndOfError.lastIndexOf(&#39;\n&#39;);</b>
<b class="fc">&nbsp;    if (lastLineBreakPosInError == -1) {</b>
<b class="fc">&nbsp;      endColumn = sentencePartToEndOfError.length() + columnCount;</b>
&nbsp;    } else {
<b class="fc">&nbsp;      endColumn = sentencePartToEndOfError.length() - lastLineBreakPosInError;</b>
&nbsp;    }
<b class="fc">&nbsp;    int lineBreaksToError = countLineBreaks(sentencePartToError);</b>
<b class="fc">&nbsp;    int lineBreaksToEndOfError = countLineBreaks(sentencePartToEndOfError);</b>
<b class="fc">&nbsp;    thisMatch.setLine(lineCount + lineBreaksToError);</b>
<b class="fc">&nbsp;    thisMatch.setEndLine(lineCount + lineBreaksToEndOfError);</b>
<b class="fc">&nbsp;    thisMatch.setColumn(column);</b>
<b class="fc">&nbsp;    thisMatch.setEndColumn(endColumn);</b>
<b class="fc">&nbsp;    return thisMatch;</b>
&nbsp;  }
&nbsp;
&nbsp;  private List&lt;SuggestedReplacement&gt; extendSuggestions(List&lt;SuggestedReplacement&gt; replacements) {
<b class="fc">&nbsp;    List&lt;SuggestedReplacement&gt; extended = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;    for (SuggestedReplacement replacement : replacements) {</b>
<b class="fc">&nbsp;      SuggestedReplacement newReplacement = new SuggestedReplacement(replacement);</b>
<b class="fc">&nbsp;      if (replacement.getShortDescription() == null) {  // don&#39;t overwrite more specific suggestions from the rule</b>
<b class="fc">&nbsp;        String descOrNull = descProvider.getShortDescription(replacement.getReplacement(), language);</b>
<b class="fc">&nbsp;        newReplacement.setShortDescription(descOrNull);</b>
<b class="fc">&nbsp;        newReplacement.setSuffix(replacement.getSuffix());</b>
&nbsp;      }
<b class="fc">&nbsp;      extended.add(newReplacement);</b>
&nbsp;    }
<b class="fc">&nbsp;    return extended;</b>
&nbsp;  }
&nbsp;
&nbsp;  protected void rememberUnknownWords(AnalyzedSentence analyzedText) {
<b class="fc">&nbsp;    if (listUnknownWords) {</b>
<b class="fc">&nbsp;      AnalyzedTokenReadings[] atr = analyzedText.getTokensWithoutWhitespace();</b>
<b class="fc">&nbsp;      for (AnalyzedTokenReadings reading : atr) {</b>
<b class="fc">&nbsp;        if (!reading.isTagged()) {</b>
<b class="fc">&nbsp;          unknownWords.add(reading.getToken());</b>
&nbsp;        }
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Get the alphabetically sorted list of unknown words in the latest run of one of the {@link #check(String)} methods.
&nbsp;   *
&nbsp;   * @throws IllegalStateException if {@link #setListUnknownWords(boolean)} has been set to {@code false}
&nbsp;   */
&nbsp;  public List&lt;String&gt; getUnknownWords() {
<b class="pc">&nbsp;    if (!listUnknownWords) {</b>
<b class="nc">&nbsp;      throw new IllegalStateException(&quot;listUnknownWords is set to false, unknown words not stored&quot;);</b>
&nbsp;    }
<b class="fc">&nbsp;    List&lt;String&gt; words = new ArrayList&lt;&gt;(unknownWords);</b>
<b class="fc">&nbsp;    Collections.sort(words);</b>
<b class="fc">&nbsp;    return words;</b>
&nbsp;  }
&nbsp;
&nbsp;  // non-private only for test case
&nbsp;  static int countLineBreaks(String s) {
<b class="fc">&nbsp;    int pos = -1;</b>
<b class="fc">&nbsp;    int count = 0;</b>
&nbsp;    while (true) {
<b class="fc">&nbsp;      int nextPos = s.indexOf(&#39;\n&#39;, pos + 1);</b>
<b class="fc">&nbsp;      if (nextPos == -1) {</b>
&nbsp;        break;
&nbsp;      }
<b class="fc">&nbsp;      pos = nextPos;</b>
<b class="fc">&nbsp;      count++;</b>
&nbsp;    }
<b class="fc">&nbsp;    return count;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Tokenizes the given {@code sentence} into words and analyzes it,
&nbsp;   * and then disambiguates POS tags.
&nbsp;   *
&nbsp;   * @param sentence sentence to be analyzed
&nbsp;   */
&nbsp;  public AnalyzedSentence getAnalyzedSentence(String sentence) throws IOException {
<b class="fc">&nbsp;    SimpleInputSentence cacheKey = new SimpleInputSentence(sentence, language);</b>
<b class="pc">&nbsp;    AnalyzedSentence cachedSentence = cache != null ? cache.getIfPresent(cacheKey) : null;</b>
<b class="pc">&nbsp;    if (cachedSentence != null) {</b>
<b class="nc">&nbsp;      return cachedSentence;</b>
&nbsp;    } else {
<b class="fc">&nbsp;      AnalyzedSentence raw = getRawAnalyzedSentence(sentence);</b>
<b class="fc">&nbsp;      AnalyzedSentence disambig = language.getDisambiguator().disambiguate(raw, checkCancelledCallback);</b>
<b class="fc">&nbsp;      AnalyzedSentence analyzedSentence = new AnalyzedSentence(disambig.getTokens(), raw.getTokens());</b>
<b class="fc">&nbsp;      if (language.getPostDisambiguationChunker() != null) {</b>
<b class="fc">&nbsp;        language.getPostDisambiguationChunker().addChunkTags(Arrays.asList(analyzedSentence.getTokens()));</b>
&nbsp;      }
<b class="pc">&nbsp;      if (cache != null) {</b>
<b class="nc">&nbsp;        cache.put(cacheKey, analyzedSentence);</b>
&nbsp;      }
<b class="fc">&nbsp;      return analyzedSentence;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  static class CleanToken {
&nbsp;    private final String origToken;
&nbsp;    private final String cleanToken;
<b class="nc">&nbsp;    CleanToken(String origToken, String cleanToken) {</b>
<b class="nc">&nbsp;      this.origToken = origToken;</b>
<b class="nc">&nbsp;      this.cleanToken = cleanToken;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Tokenizes the given {@code sentence} into words and analyzes it.
&nbsp;   * This is the same as {@link #getAnalyzedSentence(String)} but it does not run
&nbsp;   * the disambiguator.
&nbsp;   *
&nbsp;   * @param sentence sentence to be analyzed
&nbsp;   * @since 0.9.8
&nbsp;   */
&nbsp;  public AnalyzedSentence getRawAnalyzedSentence(String sentence) throws IOException {
<b class="fc">&nbsp;    List&lt;String&gt; tokens = language.getWordTokenizer().tokenize(sentence);</b>
<b class="fc">&nbsp;    Map&lt;Integer, CleanToken&gt; softHyphenTokens = replaceSoftHyphens(tokens);</b>
&nbsp;
<b class="fc">&nbsp;    List&lt;AnalyzedTokenReadings&gt; aTokens = language.getTagger().tag(tokens);</b>
<b class="fc">&nbsp;    if (language.getChunker() != null) {</b>
<b class="fc">&nbsp;      language.getChunker().addChunkTags(aTokens);</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    AnalyzedTokenReadings[] tokenArray = new AnalyzedTokenReadings[tokens.size() + 1];</b>
<b class="fc">&nbsp;    AnalyzedToken[] startTokenArray = new AnalyzedToken[1];</b>
<b class="fc">&nbsp;    int toArrayCount = 0;</b>
<b class="fc">&nbsp;    AnalyzedToken sentenceStartToken = new AnalyzedToken(&quot;&quot;, SENTENCE_START_TAGNAME, null);</b>
<b class="fc">&nbsp;    startTokenArray[0] = sentenceStartToken;</b>
<b class="fc">&nbsp;    tokenArray[toArrayCount++] = new AnalyzedTokenReadings(startTokenArray, 0);</b>
<b class="fc">&nbsp;    int startPos = 0;</b>
<b class="fc">&nbsp;    for (AnalyzedTokenReadings posTag : aTokens) {</b>
<b class="fc">&nbsp;      posTag.setStartPos(startPos);</b>
<b class="fc">&nbsp;      tokenArray[toArrayCount++] = posTag;</b>
<b class="fc">&nbsp;      startPos += posTag.getToken().length();</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    int numTokens = aTokens.size();</b>
<b class="fc">&nbsp;    int posFix = 0;</b>
<b class="fc">&nbsp;    for (int i = 0; i &lt; numTokens; i++) {</b>
<b class="fc">&nbsp;      if (i &gt; 0) {</b>
<b class="fc">&nbsp;        aTokens.get(i).setWhitespaceBefore(aTokens.get(i - 1).getToken());</b>
<b class="fc">&nbsp;        aTokens.get(i).setStartPos(aTokens.get(i).getStartPos() + posFix);</b>
<b class="fc">&nbsp;        aTokens.get(i).setPosFix(posFix);</b>
&nbsp;      }
<b class="pc">&nbsp;      if (!softHyphenTokens.isEmpty() &amp;&amp; softHyphenTokens.get(i) != null) {</b>
&nbsp;        // addReading() modifies a readings.token if last token is longer - need to use it first
<b class="nc">&nbsp;        posFix += softHyphenTokens.get(i).origToken.length() - aTokens.get(i).getToken().length();</b>
<b class="nc">&nbsp;        AnalyzedToken newToken = language.getTagger().createToken(softHyphenTokens.get(i).origToken, null);</b>
<b class="nc">&nbsp;        aTokens.get(i).addReading(newToken, &quot;softHyphenTokens&quot;);</b>
<b class="nc">&nbsp;        aTokens.get(i).setCleanToken(softHyphenTokens.get(i).cleanToken);</b>
&nbsp;      }
&nbsp;    }
&nbsp;
&nbsp;    // add additional tags
<b class="fc">&nbsp;    int lastToken = toArrayCount - 1;</b>
&nbsp;    // make SENT_END appear at last not whitespace token
<b class="pc">&nbsp;    for (int i = 0; i &lt; toArrayCount - 1; i++) {</b>
<b class="fc">&nbsp;      if (!tokenArray[lastToken - i].isWhitespace()) {</b>
<b class="fc">&nbsp;        lastToken -= i;</b>
&nbsp;        break;
&nbsp;      }
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    tokenArray[lastToken].setSentEnd();</b>
&nbsp;
<b class="pc">&nbsp;    if (tokenArray.length == lastToken + 1 &amp;&amp; tokenArray[lastToken].isLinebreak()) {</b>
<b class="nc">&nbsp;      tokenArray[lastToken].setParagraphEnd();</b>
&nbsp;    }
<b class="fc">&nbsp;    return new AnalyzedSentence(tokenArray);</b>
&nbsp;  }
&nbsp;
&nbsp;  private Map&lt;Integer, CleanToken&gt; replaceSoftHyphens(List&lt;String&gt; tokens) {
<b class="fc">&nbsp;    Pattern ignoredCharacterRegex = language.getIgnoredCharactersRegex();</b>
<b class="fc">&nbsp;    Map&lt;Integer, CleanToken&gt; ignoredCharsTokens = new HashMap&lt;&gt;();</b>
<b class="pc">&nbsp;    if (ignoredCharacterRegex == null) {</b>
<b class="nc">&nbsp;      return ignoredCharsTokens;</b>
&nbsp;    }
<b class="fc">&nbsp;    for (int i = 0; i &lt; tokens.size(); i++) {</b>
<b class="fc">&nbsp;      Matcher matcher = ignoredCharacterRegex.matcher(tokens.get(i));</b>
<b class="pc">&nbsp;      if (matcher.find()) {</b>
<b class="nc">&nbsp;        String cleaned = matcher.replaceAll(&quot;&quot;);</b>
<b class="nc">&nbsp;        ignoredCharsTokens.put(i, new CleanToken(tokens.get(i), cleaned));</b>
<b class="nc">&nbsp;        tokens.set(i, matcher.replaceAll(&quot;&quot;));</b>
&nbsp;      }
&nbsp;    }
<b class="fc">&nbsp;    return ignoredCharsTokens;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Get all rule categories for the current language.
&nbsp;   *
&nbsp;   * @return a map of {@link Category Categories}, keyed by their {@link CategoryId id}.
&nbsp;   * @since 3.5
&nbsp;   */
&nbsp;  public Map&lt;CategoryId, Category&gt; getCategories() {
<b class="nc">&nbsp;    Map&lt;CategoryId, Category&gt; map = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;    for (Rule rule : getAllRules()) {</b>
<b class="nc">&nbsp;      map.put(rule.getCategory().getId(), rule.getCategory());</b>
&nbsp;    }
<b class="nc">&nbsp;    return map;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Get all rules for the current language that are built-in or that have been
&nbsp;   * added using {@link #addRule(Rule)}. Please note that XML rules that are grouped
&nbsp;   * will appear as multiple rules with the same id. To tell them apart, check if
&nbsp;   * they are of type {@code AbstractPatternRule}, cast them to that type and call
&nbsp;   * their {@link AbstractPatternRule#getSubId()} method.
&nbsp;   *
&nbsp;   * @return a List of {@link Rule} objects
&nbsp;   */
&nbsp;  public List&lt;Rule&gt; getAllRules() {
<b class="fc">&nbsp;    List&lt;Rule&gt; rules = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;    rules.addAll(builtinRules);</b>
<b class="fc">&nbsp;    rules.addAll(userRules);</b>
<b class="fc">&nbsp;    return rules;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Get all active (not disabled) rules for the current language that are built-in or that
&nbsp;   * have been added using e.g. {@link #addRule(Rule)}. See {@link #getAllRules()} for hints
&nbsp;   * about rule ids.
&nbsp;   *
&nbsp;   * @return a List of {@link Rule} objects
&nbsp;   */
&nbsp;  public List&lt;Rule&gt; getAllActiveRules() {
<b class="fc">&nbsp;    List&lt;Rule&gt; rules = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;    List&lt;Rule&gt; rulesActive = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;    rules.addAll(builtinRules);</b>
<b class="fc">&nbsp;    rules.addAll(userRules);</b>
&nbsp;    // Some rules have an internal state so they can do checks over sentence
&nbsp;    // boundaries. These need to be reset so the checks don&#39;t suddenly
&nbsp;    // work on different texts with the same data. However, it could be useful
&nbsp;    // to keep the state information if we&#39;re checking a continuous text.    
<b class="fc">&nbsp;    for (Rule rule : rules) {</b>
<b class="fc">&nbsp;      if (!ignoreRule(rule)) {</b>
<b class="fc">&nbsp;        rulesActive.add(rule);</b>
&nbsp;      }
&nbsp;    }
<b class="fc">&nbsp;    return rulesActive;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Get all spelling check rules for the current language that are built-in or
&nbsp;   * that have been added using {@link #addRule(Rule)}.
&nbsp;   *
&nbsp;   * @return a List of {@link SpellingCheckRule} objects
&nbsp;   * @since 5.0
&nbsp;   */
&nbsp;  public List&lt;SpellingCheckRule&gt; getAllSpellingCheckRules() {
<b class="nc">&nbsp;    List&lt;SpellingCheckRule&gt; rules = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;    for (Rule rule : builtinRules) {</b>
<b class="nc">&nbsp;      if (rule instanceof SpellingCheckRule) {</b>
<b class="nc">&nbsp;        rules.add((SpellingCheckRule) rule);</b>
&nbsp;      }
&nbsp;    }
<b class="nc">&nbsp;    for (Rule rule : userRules) {</b>
<b class="nc">&nbsp;      if (rule instanceof SpellingCheckRule) {</b>
<b class="nc">&nbsp;        rules.add((SpellingCheckRule) rule);</b>
&nbsp;      }
&nbsp;    }
<b class="nc">&nbsp;    return rules;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Works like getAllActiveRules but overrides defaults by office defaults
&nbsp;   *
&nbsp;   * @return a List of {@link Rule} objects
&nbsp;   * @since 4.0
&nbsp;   */
&nbsp;  public List&lt;Rule&gt; getAllActiveOfficeRules() {
<b class="nc">&nbsp;    List&lt;Rule&gt; rules = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;    List&lt;Rule&gt; rulesActive = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;    rules.addAll(builtinRules);</b>
<b class="nc">&nbsp;    rules.addAll(userRules);</b>
<b class="nc">&nbsp;    for (Rule rule : rules) {</b>
<b class="nc">&nbsp;      if (!ignoreRule(rule) &amp;&amp; !rule.isOfficeDefaultOff()) {</b>
<b class="nc">&nbsp;        rulesActive.add(rule);</b>
<b class="nc">&nbsp;      } else if (rule.isOfficeDefaultOn() &amp;&amp; !disabledRules.contains(rule.getId())) {</b>
<b class="nc">&nbsp;        rulesActive.add(rule);</b>
<b class="nc">&nbsp;        enableRule(rule.getId());</b>
<b class="nc">&nbsp;      } else if (!ignoreRule(rule) &amp;&amp; rule.isOfficeDefaultOff() &amp;&amp; !enabledRules.contains(rule.getId())) {</b>
<b class="nc">&nbsp;        disableRule(rule.getId());</b>
&nbsp;      }
&nbsp;    }
<b class="nc">&nbsp;    return rulesActive;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Get pattern rules by Id and SubId. This returns a list because rules that use {@code &lt;or&gt;...&lt;/or&gt;}
&nbsp;   * are internally expanded into several rules.
&nbsp;   *
&nbsp;   * @return a List of {@link Rule} objects
&nbsp;   * @since 2.3
&nbsp;   */
&nbsp;  public List&lt;AbstractPatternRule&gt; getPatternRulesByIdAndSubId(String id, String subId) {
<b class="nc">&nbsp;    List&lt;Rule&gt; rules = getAllRules();</b>
<b class="nc">&nbsp;    List&lt;AbstractPatternRule&gt; rulesById = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;    for (Rule rule : rules) {</b>
<b class="nc">&nbsp;      if (id.startsWith(rule.getId())) {</b>
&nbsp;        // test wrapped rules as normal in PatternRuleTest
<b class="nc">&nbsp;        if (rule instanceof ConsistencyPatternRuleTransformer.ConsistencyPatternRule) {</b>
<b class="nc">&nbsp;          List&lt;AbstractPatternRule&gt; wrappedRules = ((ConsistencyPatternRuleTransformer.ConsistencyPatternRule) rule).getWrappedRules();</b>
<b class="nc">&nbsp;          rulesById.addAll(wrappedRules.stream().filter(r -&gt; r.getSubId().equals(subId)).collect(Collectors.toList()));</b>
&nbsp;        }
&nbsp;      }
<b class="nc">&nbsp;      if (rule.getId().equals(id)) {</b>
&nbsp;        // test wrapped rules as normal in PatternRuleTest
<b class="nc">&nbsp;        if (rule instanceof RepeatedPatternRuleTransformer.RepeatedPatternRule) {</b>
<b class="nc">&nbsp;          List&lt;AbstractPatternRule&gt; wrappedRules = ((RepeatedPatternRuleTransformer.RepeatedPatternRule) rule).getWrappedRules();</b>
<b class="nc">&nbsp;          rulesById.addAll(wrappedRules.stream().filter(r -&gt; r.getSubId().equals(subId)).collect(Collectors.toList()));</b>
&nbsp;        }
<b class="nc">&nbsp;        else if (rule instanceof AbstractPatternRule &amp;&amp; rule.getSubId().equals(subId)){</b>
<b class="nc">&nbsp;          rulesById.add((AbstractPatternRule) rule);</b>
&nbsp;        }
&nbsp;      }
&nbsp;    }
<b class="nc">&nbsp;    return rulesById;</b>
&nbsp;  }
&nbsp;
&nbsp;  protected void printIfVerbose(String s) {
<b class="pc">&nbsp;    if (printStream != null) {</b>
<b class="fc">&nbsp;      printStream.println(s);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Adds a temporary file to the internal list
&nbsp;   * (internal method, you should never need to call this as a user of LanguageTool)
&nbsp;   *
&nbsp;   * @param file the file to be added.
&nbsp;   */
&nbsp;  public static void addTemporaryFile(File file) {
<b class="nc">&nbsp;    temporaryFiles.add(file);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Clean up all temporary files, if there are any.
&nbsp;   */
&nbsp;  public static void removeTemporaryFiles() {
<b class="pc">&nbsp;    for (File file : temporaryFiles) {</b>
<b class="nc">&nbsp;      file.delete();</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * should be called just once with complete list of matches, before returning them to caller
&nbsp;   *
&nbsp;   * @param matches matches after applying rules and default filters
&nbsp;   * @param text    text that matches refer to
&nbsp;   * @return transformed matches (after applying filters in {@link #matchFilters})
&nbsp;   * @since 4.7
&nbsp;   */
&nbsp;  protected List&lt;RuleMatch&gt; applyCustomFilters(List&lt;RuleMatch&gt; matches, AnnotatedText text) {
<b class="fc">&nbsp;    List&lt;RuleMatch&gt; transformed = matches;</b>
<b class="pc">&nbsp;    for (RuleMatchFilter filter : matchFilters) {</b>
<b class="nc">&nbsp;      transformed = filter.filter(transformed, text);</b>
&nbsp;    }
<b class="fc">&nbsp;    return transformed;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Callback for checking if result of {@link #check(String)} is still needed.
&nbsp;   */
&nbsp;  public interface CheckCancelledCallback {
&nbsp;    /**
&nbsp;     * @return true if request was cancelled else false
&nbsp;     */
&nbsp;    boolean checkCancelled();
&nbsp;  }
&nbsp;
&nbsp;  static class SentenceData {
&nbsp;    final AnalyzedSentence analyzed;
&nbsp;    private final String text;
&nbsp;    private final int startOffset;
&nbsp;    private final int startLine;
&nbsp;    private final int startColumn;
&nbsp;    private final int wordCount;
&nbsp;
<b class="fc">&nbsp;    SentenceData(AnalyzedSentence analyzed, String text, int startOffset, int startLine, int startColumn) {</b>
<b class="fc">&nbsp;      this.analyzed = analyzed;</b>
<b class="fc">&nbsp;      this.text = text;</b>
<b class="fc">&nbsp;      this.startOffset = startOffset;</b>
<b class="fc">&nbsp;      this.startLine = startLine;</b>
<b class="fc">&nbsp;      this.startColumn = startColumn;</b>
<b class="fc">&nbsp;      wordCount = analyzed.getTokensWithoutWhitespace().length;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  class TextCheckCallable implements Callable&lt;CheckResults&gt; {
&nbsp;    private final RuleSet rules;
&nbsp;    private final boolean checkRemoteRules;
&nbsp;    private final ParagraphHandling paraMode;
&nbsp;    private final AnnotatedText annotatedText;
&nbsp;    private final List&lt;SentenceData&gt; sentences;
&nbsp;    private final RuleMatchListener listener;
&nbsp;    private final Mode mode;
&nbsp;    private final Level level;
&nbsp;    private final Set&lt;ToneTag&gt; toneTags;
&nbsp;
&nbsp;    TextCheckCallable(RuleSet rules, List&lt;SentenceData&gt; sentences,
&nbsp;                      ParagraphHandling paraMode, AnnotatedText annotatedText,
<b class="fc">&nbsp;                      RuleMatchListener listener, Mode mode, Level level, boolean checkRemoteRules, Set&lt;ToneTag&gt; toneTags) {</b>
<b class="fc">&nbsp;      this.rules = rules;</b>
<b class="fc">&nbsp;      this.checkRemoteRules = checkRemoteRules;</b>
<b class="fc">&nbsp;      this.sentences = Objects.requireNonNull(sentences);</b>
<b class="fc">&nbsp;      this.paraMode = Objects.requireNonNull(paraMode);</b>
<b class="fc">&nbsp;      this.annotatedText = Objects.requireNonNull(annotatedText);</b>
<b class="fc">&nbsp;      this.listener = listener;</b>
<b class="fc">&nbsp;      this.mode = Objects.requireNonNull(mode);</b>
<b class="fc">&nbsp;      this.level = Objects.requireNonNull(level);</b>
<b class="fc">&nbsp;      this.toneTags = toneTags;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public CheckResults call() throws Exception {
<b class="fc">&nbsp;      List&lt;RuleMatch&gt; ruleMatches = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;      List&lt;Range&gt; ignoreRanges = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;      List&lt;ExtendedSentenceRange&gt; extendedSentenceRanges = new ArrayList&lt;&gt;();</b>
<b class="pc">&nbsp;      if (mode == Mode.ALL) {</b>
<b class="fc">&nbsp;        ruleMatches.addAll(getTextLevelRuleMatches());</b>
<b class="fc">&nbsp;        CheckResults otherRuleMatches = getOtherRuleMatches(toneTags);</b>
<b class="fc">&nbsp;        ruleMatches.addAll(otherRuleMatches.getRuleMatches());</b>
<b class="fc">&nbsp;        ignoreRanges.addAll(otherRuleMatches.getIgnoredRanges());</b>
<b class="fc">&nbsp;        extendedSentenceRanges.addAll(otherRuleMatches.getExtendedSentenceRanges());</b>
<b class="pc">&nbsp;      } else if (mode == Mode.ALL_BUT_TEXTLEVEL_ONLY) {</b>
<b class="nc">&nbsp;        CheckResults otherRuleMatches = getOtherRuleMatches(toneTags);</b>
<b class="nc">&nbsp;        ruleMatches.addAll(otherRuleMatches.getRuleMatches());</b>
<b class="nc">&nbsp;        ignoreRanges.addAll(otherRuleMatches.getIgnoredRanges());</b>
<b class="nc">&nbsp;        extendedSentenceRanges.addAll(otherRuleMatches.getExtendedSentenceRanges());</b>
<b class="nc">&nbsp;      } else if (mode == Mode.TEXTLEVEL_ONLY) {</b>
<b class="nc">&nbsp;        ruleMatches.addAll(getTextLevelRuleMatches());</b>
&nbsp;      } else {
<b class="nc">&nbsp;        throw new IllegalArgumentException(&quot;Unknown mode: &quot; + mode);</b>
&nbsp;      }
&nbsp;      // can&#39;t call applyCustomRuleFilters here, done in performCheck -&gt;
&nbsp;      // should run just once w/ complete list of matches
<b class="fc">&nbsp;      return new CheckResults(ruleMatches, ignoreRanges, extendedSentenceRanges);</b>
&nbsp;    }
&nbsp;
&nbsp;    private List&lt;RuleMatch&gt; getTextLevelRuleMatches() throws IOException {
<b class="fc">&nbsp;      List&lt;RuleMatch&gt; ruleMatches = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;      List&lt;AnalyzedSentence&gt; analyzedSentences = null;</b>
<b class="fc">&nbsp;      for (Rule rule : rules.allRules()) {</b>
<b class="pc">&nbsp;        if (rule instanceof TextLevelRule &amp;&amp; paraMode != ParagraphHandling.ONLYNONPARA) {</b>
<b class="pc">&nbsp;          if (checkCancelledCallback != null &amp;&amp; checkCancelledCallback.checkCancelled()) {</b>
&nbsp;            break;
&nbsp;          }
<b class="pc">&nbsp;          if (analyzedSentences == null) {</b>
<b class="fc">&nbsp;            analyzedSentences = sentences.stream().map(s -&gt; s.analyzed).collect(Collectors.toList());</b>
&nbsp;          }
<b class="fc">&nbsp;          RuleMatch[] matches = ((TextLevelRule) rule).match(analyzedSentences, annotatedText);</b>
<b class="fc">&nbsp;          List&lt;RuleMatch&gt; adaptedMatches = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;          for (RuleMatch match : matches) {</b>
&nbsp;            LineColumnPosition from;
&nbsp;            LineColumnPosition to;
&nbsp;            try {
<b class="fc">&nbsp;              from = findLineColumn(match.getFromPos());</b>
<b class="fc">&nbsp;              to = findLineColumn(match.getToPos());</b>
&nbsp;            } catch (RuntimeException e) {
<b class="nc">&nbsp;              throw new RuntimeException(&quot;Getting line/column positions failed for match &quot; + match + &quot; Sentence: &quot; + match.getSentence().getText(), e);</b>
&nbsp;            }
&nbsp;            int newFromPos;
&nbsp;            int newToPos;
&nbsp;            try {
<b class="fc">&nbsp;              newFromPos = annotatedText.getOriginalTextPositionFor(match.getFromPos(), false);</b>
<b class="fc">&nbsp;              newToPos = annotatedText.getOriginalTextPositionFor(match.getToPos() - 1, true) + 1;</b>
&nbsp;            } catch (RuntimeException e) {
<b class="nc">&nbsp;              throw new RuntimeException(&quot;Getting positions failed for match &quot; + match + &quot; Sentence: &quot; + match.getSentence().getText(), e);</b>
&nbsp;            }
<b class="fc">&nbsp;            RuleMatch newMatch = new RuleMatch(match);</b>
<b class="fc">&nbsp;            newMatch.setOffsetPosition(newFromPos, newToPos);</b>
<b class="fc">&nbsp;            newMatch.setLine(from.line);</b>
<b class="fc">&nbsp;            newMatch.setEndLine(to.line);</b>
<b class="fc">&nbsp;            newMatch.setColumn(from.column - (from.line == 0 ? 1 : 0));</b>
<b class="fc">&nbsp;            newMatch.setEndColumn(to.column - (to.line == 0 ? 1 : 0));</b>
<b class="fc">&nbsp;            newMatch.setSuggestedReplacementObjects(extendSuggestions(match.getSuggestedReplacementObjects()));</b>
<b class="fc">&nbsp;            adaptedMatches.add(newMatch);</b>
&nbsp;          }
<b class="fc">&nbsp;          ruleMatches.addAll(adaptedMatches);</b>
<b class="pc">&nbsp;          if (listener != null) {</b>
<b class="nc">&nbsp;            for (RuleMatch adaptedMatch : adaptedMatches) {</b>
<b class="nc">&nbsp;              listener.matchFound(adaptedMatch);</b>
&nbsp;            }
&nbsp;          }
&nbsp;        }
&nbsp;      }
<b class="fc">&nbsp;      return ruleMatches;</b>
&nbsp;    }
&nbsp;
&nbsp;    private CheckResults getOtherRuleMatches(Set&lt;ToneTag&gt; toneTags) {
<b class="fc">&nbsp;      List&lt;RuleMatch&gt; ruleMatches = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;      List&lt;Range&gt; ignoreRanges = new ArrayList&lt;&gt;(); //TODO: remove later</b>
<b class="fc">&nbsp;      List&lt;ExtendedSentenceRange&gt; extendedSentenceRanges = new ArrayList&lt;&gt;();</b>
&nbsp;
<b class="fc">&nbsp;      int textWordCounter = sentences.stream().map(sentenceData -&gt; sentenceData.wordCount).reduce(0, Integer::sum);</b>
<b class="fc">&nbsp;      int wordCounter = 0;</b>
<b class="fc">&nbsp;      float tmpErrorsPerWord = 0.0f;</b>
<b class="fc">&nbsp;      List&lt;String&gt; errorRateLog = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;      for (int i = 0, sentencesSize = sentences.size(); i &lt; sentencesSize; i++) {</b>
<b class="fc">&nbsp;        SentenceData sentence = sentences.get(i);</b>
<b class="fc">&nbsp;        wordCounter += sentence.wordCount;</b>
<b class="fc">&nbsp;        ExtendedSentenceRange extendedSentenceRange = new ExtendedSentenceRange(sentence.startOffset, sentence.startOffset + sentence.text.trim().length(), language.getShortCode());</b>
<b class="fc">&nbsp;        extendedSentenceRanges.add(extendedSentenceRange);</b>
&nbsp;        try {
&nbsp;          //comment in to trigger an exception via input text:
&nbsp;          //if (analyzedSentence.getText().contains(&quot;fakecrash&quot;)) {
&nbsp;          //  throw new RuntimeException(&quot;fake crash&quot;);
&nbsp;          //}
<b class="fc">&nbsp;          List&lt;RuleMatch&gt; sentenceMatches = null;</b>
<b class="fc">&nbsp;          InputSentence cacheKey = null;</b>
<b class="pc">&nbsp;          if (cache != null) {</b>
<b class="nc">&nbsp;            cacheKey = new InputSentence(sentence.text, language, motherTongue,</b>
&nbsp;                    disabledRules, disabledRuleCategories,
&nbsp;                    enabledRules, enabledRuleCategories, userConfig, altLanguages, mode, level, toneTags);
<b class="nc">&nbsp;            sentenceMatches = cache.getIfPresent(cacheKey);</b>
&nbsp;          }
<b class="pc">&nbsp;          if (sentenceMatches == null) {</b>
<b class="fc">&nbsp;            List&lt;Rule&gt; rules = new ArrayList&lt;&gt;(this.rules.rulesForSentence(sentence.analyzed));</b>
<b class="fc">&nbsp;            rules.addAll(userConfig.getRules());</b>
<b class="fc">&nbsp;            sentenceMatches = checkAnalyzedSentence(paraMode, rules, sentence.analyzed, checkRemoteRules, textWordCounter);</b>
&nbsp;          }
<b class="pc">&nbsp;          if (cache != null) {</b>
<b class="nc">&nbsp;            cache.put(cacheKey, sentenceMatches);</b>
&nbsp;          }
<b class="fc">&nbsp;          if (!sentenceMatches.isEmpty()) {</b>
<b class="pc">&nbsp;            if (checkCancelledCallback != null &amp;&amp; checkCancelledCallback.checkCancelled()) {</b>
&nbsp;              break;
&nbsp;            }
<b class="fc">&nbsp;            for (RuleMatch elem : sentenceMatches) {</b>
<b class="fc">&nbsp;              RuleMatch thisMatch = adjustRuleMatchPos(elem, sentence.startOffset, sentence.startColumn, sentence.startLine, sentence.text, annotatedText);</b>
<b class="pc">&nbsp;              if (!elem.getNewLanguageMatches().isEmpty()) {</b>
&nbsp;                //TODO: remove after the addon is updated
<b class="nc">&nbsp;                Range ignoreRange = new Range(sentence.startOffset, sentence.startOffset + sentence.text.length(), elem.getNewLanguageMatches().entrySet().iterator().next().getKey());</b>
<b class="nc">&nbsp;                if (!ignoreRanges.contains(ignoreRange)) {</b>
<b class="nc">&nbsp;                  ignoreRanges.add(ignoreRange);</b>
&nbsp;                }
<b class="nc">&nbsp;                extendedSentenceRange.updateLanguageConfidenceRates(elem.getNewLanguageMatches());</b>
&nbsp;              }
<b class="fc">&nbsp;              ruleMatches.add(thisMatch);</b>
<b class="pc">&nbsp;              if (listener != null) {</b>
<b class="nc">&nbsp;                listener.matchFound(thisMatch);</b>
&nbsp;              }
&nbsp;            }
&nbsp;          }
<b class="fc">&nbsp;          float errorsPerWord = ruleMatches.size() / (float) wordCounter;</b>
<b class="fc">&nbsp;          if (tmpErrorsPerWord &lt; errorsPerWord) {</b>
<b class="fc">&nbsp;            errorRateLog.add(&quot;With sentence: &quot; + (i + 1) + &quot; (of &quot; + sentencesSize + &quot;) the text error rate increased by: &quot; + (errorsPerWord - tmpErrorsPerWord) + &quot; from: &quot; + tmpErrorsPerWord  + &quot; to total: &quot; + errorsPerWord);</b>
<b class="fc">&nbsp;            tmpErrorsPerWord = errorsPerWord;</b>
&nbsp;          }
<b class="pc">&nbsp;          if (maxErrorsPerWordRate &gt; 0 &amp;&amp; errorsPerWord &gt; maxErrorsPerWordRate &amp;&amp; wordCounter &gt; 25) {</b>
<b class="nc">&nbsp;            errorRateLog.forEach(e -&gt; logger.info(LoggingTools.BAD_REQUEST, e));</b>
<b class="nc">&nbsp;            throw new ErrorRateTooHighException(&quot;Text checking was stopped due to too many errors (more than &quot; + String.format(&quot;%.0f&quot;, maxErrorsPerWordRate * 100) +</b>
<b class="nc">&nbsp;              &quot;% of words seem to have an error). Are you sure you have set the correct text language? Language set: &quot; + JLanguageTool.this.language.getName() +</b>
<b class="nc">&nbsp;              &quot;, text length: &quot; + annotatedText.getPlainText().length());</b>
&nbsp;            //        &quot;, text length: &quot; + annotatedText.getPlainText().length() + &quot;, common word count: &quot; + commonWords.getKnownWordsPerLanguage(annotatedText.getPlainText()));
&nbsp;          }
&nbsp;        } catch (ErrorRateTooHighException e) {
&nbsp;          throw e;
&nbsp;        } catch (StackOverflowError e) {
<b class="nc">&nbsp;          System.out.println(&quot;Could not check sentence due to StackOverflowError (language: &quot; + language + &quot;): &lt;sentcontent&gt;&quot;</b>
<b class="nc">&nbsp;                  + StringUtils.abbreviate(sentence.analyzed.toTextString(), 10_000) + &quot;&lt;/sentcontent&gt;&quot;);</b>
&nbsp;          throw e;
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;          throw new RuntimeException(&quot;Could not check sentence (language: &quot; + language + &quot;): &lt;sentcontent&gt;&quot;</b>
<b class="nc">&nbsp;                  + StringUtils.abbreviate(sentence.analyzed.toTextString(), 500) + &quot;&lt;/sentcontent&gt;&quot;, e);</b>
&nbsp;        }
&nbsp;      }
<b class="fc">&nbsp;      return new CheckResults(ruleMatches, ignoreRanges, extendedSentenceRanges);</b>
&nbsp;    }
&nbsp;
&nbsp;    private LineColumnPosition findLineColumn(int offset) {
<b class="pc">&nbsp;      if (sentences.isEmpty()) return new LineColumnPosition(0, 0);</b>
&nbsp;
<b class="fc">&nbsp;      SentenceData sentence = findSentenceContaining(offset);</b>
<b class="fc">&nbsp;      String prefix = sentence.text.substring(0, offset - sentence.startOffset);</b>
<b class="fc">&nbsp;      return new LineColumnPosition(</b>
<b class="fc">&nbsp;        sentence.startLine + countLineBreaks(prefix),</b>
<b class="fc">&nbsp;        processColumnChange(sentence.startColumn, prefix));</b>
&nbsp;    }
&nbsp;
&nbsp;    private SentenceData findSentenceContaining(int offset) {
<b class="fc">&nbsp;      int low = 0;</b>
<b class="fc">&nbsp;      int high = sentences.size() - 1;</b>
<b class="fc">&nbsp;      while (low &lt;= high) {</b>
<b class="fc">&nbsp;        int mid = (low + high) / 2;</b>
<b class="fc">&nbsp;        SentenceData sentence = sentences.get(mid);</b>
<b class="fc">&nbsp;        if (sentence.startOffset &lt; offset) low = mid + 1;</b>
<b class="pc">&nbsp;        else if (sentence.startOffset &gt; offset) high = mid - 1;</b>
<b class="fc">&nbsp;        else return sentence;</b>
&nbsp;      }
<b class="fc">&nbsp;      return sentences.get(low - 1);</b>
&nbsp;    }
&nbsp;
&nbsp;    private class LineColumnPosition {
&nbsp;      int line;
&nbsp;      int column;
&nbsp;
<b class="fc">&nbsp;      private LineColumnPosition(int line, int column) {</b>
<b class="fc">&nbsp;        this.line = line;</b>
<b class="fc">&nbsp;        this.column = column;</b>
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  public void setConfigValues(Map&lt;String, Object[]&gt; v) {
<b class="nc">&nbsp;    userConfig.insertConfigValues(v);</b>
&nbsp;  }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-02-17 23:50</div>
</div>
</body>
</html>
